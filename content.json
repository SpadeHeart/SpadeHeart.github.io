{"pages":[],"posts":[{"title":"提权学习--mysql篇(1)","text":"一、概述​ mySQL 数据库在安全领域中比较基础的使用是进行 SQL 注入，但是这种攻击方式获取到的信息比较局限，基本只能得到存在数据库里的东西，如果我们需要对目标机系统进行攻击，而我们拿到的webshell权限比较低，但是恰好有搭建 mySQL，这时就可以利用到 mySQL 对目标机进行提权操作。 ​ mySQL 所谓提权操作一般是指利用有较高权限的 mySQL 进程来执行系统函数，从而获取目标机的系统信息；这里提权是指提升攻击者操作目标机系统的权限。 ​ 大致思路：webshell（低权限）–&gt; mySQL（系统权限进程）–&gt; 系统函数执行 二、基本概念分析（1）mySQL 自定义函数​ mySQL 提供自定义函数的功能，可以让用户根据业务需要来封装特定功能的函数，这里本地演示一下： ​ 如图所示，这是一个简单的自定义函数。 （2）mySQL UDF 提权原理​ UDF是 mySQL 的一个拓展接口，UDF（User defined function）可翻译为用户自定义函数，是一个用来拓展 mySQL 的技术手段。从实际操作上来看，大致流程是我们在.dll后缀（Linux系统下是.so）的文件里编写自己的自定义函数，接着把恶意DLL库动态导入到目标机的 mySQL 的动态链接库里，就可以在目标机的 mySQL 里执行我们的自定义函数，这时如果 mySQL 进程的权限较高（比如windows下的mySQL进程一般都有管理员权限），这就使得用户自定义的函数也拥有管理员权限，我们也就拥有了执行危险系统命令的权限，这时就可以实现利用 mySQL 获得系统管理员权限的操作了。 三、实践（1）环境搭建① 实验设备​ 1.攻击机：kali 虚拟机；win10 物理机 ​ 2.靶机：ubuntu18.04 虚拟机；win10虚拟机 ② 测试环境​ ubuntu 安装apache2，php7.2.24，mysql5.7 （2）提权测试① 靶机基本信息获取​ 这里假设我们已经向目标网站上传了一句话木马getshell，并且找到了sql注入点。如图所示： ​ 这里看到在靶机里，mySQL 进程有root权限，而我们目前只有 www-data 权限。 ​ 通过这几张图，我们可以明确接下来的攻击方向：通过webshell和sql注入得到基本信息，再使用udf提权。 ② UDF提权可行性验证​ 基本信息（以 ubuntu18.04 为例）： ​ （1）@@plugin_dir –&gt; /usr/lib/mysql/plugin/（mySQL的动态链接库，udf要传到这里才能加载） ​ （2）secure_file_priv –&gt; /var/lib/mysql-files/ （通过show global variables like &quot;%secure%&quot;获取） ​ 这个属性限制了导入和导出只能在/var/lib/mysql-files/ 这个路径下，不然会出现报错： ​ ​ 我们选择把 udf 放在 mySQL 的 plugin 下实现创建自定义函数，这里我们要找一个UDF库 ​ kali的sqlmap里有，路径：/usr/share/sqlmap/data/udf/mysql/linux（windows也有对应文件夹） ③ 提权（win10虚拟机测试）1）上传udf​ 将kali里的恶意UDF（lib_mysqludf_sys.dll）上传到win10上的mySQL的插件库： ​ 路径：...\\MySQL5.7.26\\lib\\plugin ​ win10一般都有管理员权限，比较方便 ​ 2）蚁剑通过一句话马操作数据库创建自定义函数​ 3）实现提权​ ​ 这里可以看到通过提权函数得到的命令结果和虚拟机命令行里的一致。 ​ win10的系统权限管理不是很严，很多时候用户都是以管理员身份在使用电脑，这样他们搭建起来的 mySQL 服务也就具有较高的权限，这就使得提权攻击可以获取到靶机的较高权限，得以执行一些危险函数。 ④ 提权（ubuntu18.04虚拟机测试）​ 基本操作原理和上面差不多，不过注入的文件用的是lib_mysqludf_sys.so ​ 这里执行sys_eval返回可能会出现NULL，即成功注入UDF但是执行命令返回为空，解决方法我放在下面。 ​ 提权演示： 1）将udf导入靶机mysql的动态链接库​ 这里有个问题：目前我们只有www-data账户的权限，而mysql设置了导入导出路径的限制，导致无法将so文件上传到动态链接库里，这里为了测试先直接把文件拷过去。o(╥﹏╥)o ​ 2）蚁剑通过一句话马操作数据库创建自定义函数​ 3）调用恶意函数实现www-data到mysql账户的提权​ 四、问题解决（1）ubuntu系统上命令执行不成功​ 执行以下三个命令： 1sudo ln -s /etc/apparmor.d/usr.sbin.mysqld /etc/apparmor.d/disable/ 1sudo apparmor_parser -R /etc/apparmor.d/usr.sbin.mysqld 1sudo service mysql restart ​ 执行完成后即可正常提权。 （2）udf文件上传到动态链接库​ 等我学明白后续再开一篇专门讲这个","link":"/2022/05/04/%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0-mysql%E7%AF%87-1/"},{"title":"","text":"java反序列化学习-1JAVA反序列化初步学习一、概念java反序列化是为了便于存储和传输数据，将一个实例化类序列化写入一个文件，传输到另一台设备并执行反序列化，即可还原出这个实例化类并进行各项函数的调用、属性的读取等操作。 java的反序列化漏洞的思路和php有点像，也是找到危险函数通过链条调用来进行远程命令执行等操作。 二、对象序列化和反序列化的基本实现 java的序列化与反序列化是通过 对象输出流 和 对象输入流 实现的： //对象输出流 java.io.ObjectOutputStream //对象输入流 java.io.ObjectInputStream 这里放一个简单的序列化和反序列化操作过程 这是一个学生类 这是序列化和反序列化操作，分别做了简单的封装 保存序列化数据的文件直接打开的话看到的是乱码，因为序列化后的数据是二进制的 对象的反序列化有以下几个要求： 1）类需要实现Serializable接口 2）不同设备上可能对类的函数实现存在出入（比如A机器上的学生类实现了toString方法，但是B机器的学生类没有实现这个方法） 这时候需要给类定义一个serialVersionUID属性，使用private static final long修饰，这样就可以正常恢复 三、反序列化利用的基础知识&amp;原理（1）关键函数 readObject：我们对对象进行反序列化时会尝试调用对象的readObject方法， （2）readObject 跟踪 从上面的反序列化函数跟进过来，进入ObjectInputStream.java： 分析一下代码，继续跟进： 进入readObject0方法： 这一段代码调用 peekByte 方法获取 bin 的第一个字节赋值给tc 如果第一个字节等于 TC_RESET 属性值（即121）则进入 while 循环 debug发现获取到的tc为 115，那么不会进入第一个循环。 接下来会进入switch语句，根据上面得到的tc的值，这里会进入TC_OBJECT分支，跟进后进入readOrdinaryObject函数： 接着跟进到readClassDesc，这里通过switch分支进入到readNonProxyDesc函数： 这里一路debug，可以跟进到如下信息： 这里的逻辑是：创建一个 ObjectStreamClass 对象和 Class 对象 再调用 resolveClass 方法，传入的参数为 readDesc ，通过 readClassDescriptor 方法获取到的readDesc 包含着反序列化的类名和字段名等信息 接下来继续跟进： 回到 readOrdinaryObject 方法： 往下跟进看到： Class&lt;?&gt; cl = desc.forClass(); ... try { obj = desc.isInstantiable() ? desc.newInstance() : null; } ... 这段代码是从desc中获取Class类对象，再判断是否可以实例化： 继续向下： if (desc.isExternalizable()) { readExternalData((Externalizable) obj, desc); } else { readSerialData(obj, desc); } 这里调试发现是往readSerialData跳转的，两个方法都跟进一下： readExternalData 这里是如果 obj 有这个方法就调用，因为这里是跳转到readSerialData所以这个就不继续跟了 后续的操作也是各种invoke调用，就不再跟了… 四、反序列化利用简单实现首先是试一下反射调用Runtime类来执行系统命令 public class test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { //java反序列化学习 Object runtime = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,new Class[]{}).invoke(null); Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,String.class).invoke(runtime,&quot;calc.exe&quot;); } } 接下来测试利用不安全的类来利用反序列化 package com.unser1; import java.io.*; public class test2 { public static void main(String[] args) throws IOException, ClassNotFoundException { UnsafeClass Unsafe = new UnsafeClass(); Unsafe.name = &quot;弹出计算器&quot;; FileOutputStream fos = new FileOutputStream(&quot;object&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将Unsafe对象写入object文件 os.writeObject(Unsafe); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(&quot;object&quot;); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); } } Unsafe类定义： package com.unser1; import java.io.IOException; import java.io.Serializable; public class UnsafeClass implements Serializable { public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); } }","link":"/2022/05/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"}],"tags":[],"categories":[]}